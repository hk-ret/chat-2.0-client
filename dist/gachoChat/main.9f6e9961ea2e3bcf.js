"use strict"; var LR = Object.defineProperty, BR = Object.defineProperties, jR = Object.getOwnPropertyDescriptors, aC = Object.getOwnPropertySymbols, HR = Object.prototype.hasOwnProperty, $R = Object.prototype.propertyIsEnumerable, uC = (G, we, Ve) => we in G ? LR(G, we, { enumerable: !0, configurable: !0, writable: !0, value: Ve }) : G[we] = Ve, Oe = (G, we) => { for (var Ve in we || (we = {})) HR.call(we, Ve) && uC(G, Ve, we[Ve]); if (aC) for (var Ve of aC(we)) $R.call(we, Ve) && uC(G, Ve, we[Ve]); return G }, lo = (G, we) => BR(G, jR(we)); (self.webpackChunkgachoChat = self.webpackChunkgachoChat || []).push([[179], { 490: () => { function G(e) { return "function" == typeof e } function we(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const Ve = we(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function co(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class Et { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._teardowns = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (G(r)) try { r() } catch (i) { t = i instanceof Ve ? i.errors : [i] } const { _teardowns: o } = this; if (o) { this._teardowns = null; for (const i of o) try { Nd(i) } catch (s) { t = null != t ? t : [], s instanceof Ve ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new Ve(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Nd(t); else { if (t instanceof Et) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._teardowns = null !== (n = this._teardowns) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && co(n, t) } remove(t) { const { _teardowns: n } = this; n && co(n, t), t instanceof Et && t._removeParent(this) } } Et.EMPTY = (() => { const e = new Et; return e.closed = !0, e })(); const Td = Et.EMPTY; function Sd(e) { return e instanceof Et || e && "closed" in e && G(e.remove) && G(e.add) && G(e.unsubscribe) } function Nd(e) { G(e) ? e() : e.unsubscribe() } const Fn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Ii = { setTimeout(...e) { const { delegate: t } = Ii; return ((null == t ? void 0 : t.setTimeout) || setTimeout)(...e) }, clearTimeout(e) { const { delegate: t } = Ii; return ((null == t ? void 0 : t.clearTimeout) || clearTimeout)(e) }, delegate: void 0 }; function xd(e) { Ii.setTimeout(() => { const { onUnhandledError: t } = Fn; if (!t) throw e; t(e) }) } function Ai() { } const lC = va("C", void 0, void 0); function va(e, t, n) { return { kind: e, value: t, error: n } } let Rn = null; function Ti(e) { if (Fn.useDeprecatedSynchronousErrorHandling) { const t = !Rn; if (t && (Rn = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Rn; if (Rn = null, n) throw r } } else e() } class Si extends Et { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Sd(t) && t.add(this)) : this.destination = hC } static create(t, n, r) { return new wa(t, n, r) } next(t) { this.isStopped ? Ma(va("N", t, void 0), this) : this._next(t) } error(t) { this.isStopped ? Ma(va("E", void 0, t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Ma(lC, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } class wa extends Si { constructor(t, n, r) { let o; if (super(), G(t)) o = t; else if (t) { let i; ({ next: o, error: n, complete: r } = t), this && Fn.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe()) : i = t, o = null == o ? void 0 : o.bind(i), n = null == n ? void 0 : n.bind(i), r = null == r ? void 0 : r.bind(i) } this.destination = { next: o ? ba(o) : Ai, error: ba(null != n ? n : Fd), complete: r ? ba(r) : Ai } } } function ba(e, t) { return (...n) => { try { e(...n) } catch (r) { Fn.useDeprecatedSynchronousErrorHandling ? function (e) { Fn.useDeprecatedSynchronousErrorHandling && Rn && (Rn.errorThrown = !0, Rn.error = e) }(r) : xd(r) } } } function Fd(e) { throw e } function Ma(e, t) { const { onStoppedNotification: n } = Fn; n && Ii.setTimeout(() => n(e, t)) } const hC = { closed: !0, next: Ai, error: Fd, complete: Ai }, Ia = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Rd(e) { return e } let be = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function (e) { return e && e instanceof Si || function (e) { return e && G(e.next) && G(e.error) && G(e.complete) }(e) && Sd(e) }(n) ? n : new wa(n, r, o); return Ti(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Od(r))((o, i) => { let s; s = this.subscribe(a => { try { n(a) } catch (u) { i(u), null == s || s.unsubscribe() } }, i, o) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Ia]() { return this } pipe(...n) { return function (e) { return 0 === e.length ? Rd : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } }(n)(this) } toPromise(n) { return new (n = Od(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Od(e) { var t; return null !== (t = null != e ? e : Fn.Promise) && void 0 !== t ? t : Promise } const mC = we(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let ir = (() => { class e extends be { constructor() { super(), this.closed = !1, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Aa(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new mC } next(n) { Ti(() => { if (this._throwIfClosed(), !this.isStopped) { const r = this.observers.slice(); for (const o of r) o.next(n) } }) } error(n) { Ti(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Ti(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Td : (i.push(n), new Et(() => co(i, n))) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new be; return n.source = this, n } } return e.create = (t, n) => new Aa(t, n), e })(); class Aa extends ir { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : Td } } function sr(e) { return t => { if (function (e) { return G(null == e ? void 0 : e.lift) }(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } class ar extends Si { constructor(t, n, r, o, i) { super(t), this.onFinalize = i, this._next = n ? function (s) { try { n(s) } catch (a) { t.error(a) } } : super._next, this._error = o ? function (s) { try { o(s) } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (s) { t.error(s) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } function Ta(e, t) { return sr((n, r) => { let o = 0; n.subscribe(new ar(r, i => { r.next(e.call(t, i, o++)) })) }) } function Pn(e) { return this instanceof Pn ? (this.v = e, this) : new Pn(e) } function CC(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, m) { i.push([f, h, p, m]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function (f) { f.value instanceof Pn ? Promise.resolve(f.value.v).then(l, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function l(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } } function EC(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function (e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function (i, s, a, u) { Promise.resolve(u).then(function (l) { i({ value: l, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } const Bd = e => e && "number" == typeof e.length && "function" != typeof e; function jd(e) { return G(null == e ? void 0 : e.then) } function Hd(e) { return G(e[Ia]) } function $d(e) { return Symbol.asyncIterator && G(null == e ? void 0 : e[Symbol.asyncIterator]) } function Ud(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Gd = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"; function Wd(e) { return G(null == e ? void 0 : e[Gd]) } function qd(e) { return CC(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Pn(n.read()); if (o) return yield Pn(void 0); yield yield Pn(r) } } finally { n.releaseLock() } }) } function zd(e) { return G(null == e ? void 0 : e.getReader) } function On(e) { if (e instanceof be) return e; if (null != e) { if (Hd(e)) return function (e) { return new be(t => { const n = e[Ia](); if (G(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (Bd(e)) return function (e) { return new be(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (jd(e)) return function (e) { return new be(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, xd) }) }(e); if ($d(e)) return Qd(e); if (Wd(e)) return function (e) { return new be(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (zd(e)) return function (e) { return Qd(qd(e)) }(e) } throw Ud(e) } function Qd(e) { return new be(t => { (function (e, t) { var n, r, o, i; return function (e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(c) { try { l(r.next(c)) } catch (d) { s(d) } } function u(c) { try { l(r.throw(c)) } catch (d) { s(d) } } function l(c) { c.done ? i(c.value) : function (i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(c.value).then(a, u) } l((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = EC(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function pn(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Kd(e, t, n = 1 / 0) { return G(t) ? Kd((r, o) => Ta((i, s) => t(r, i, o, s))(On(e(r, o))), n) : ("number" == typeof t && (n = t), sr((r, o) => function (e, t, n, r, o, i, s, a) { const u = []; let l = 0, c = 0, d = !1; const f = () => { d && !u.length && !l && t.complete() }, h = m => l < r ? p(m) : u.push(m), p = m => { l++; let g = !1; On(n(m, c++)).subscribe(new ar(t, _ => { t.next(_) }, () => { g = !0 }, void 0, () => { if (g) try { for (l--; u.length && l < r;) { const _ = u.shift(); p(_) } f() } catch (_) { t.error(_) } })) }; return e.subscribe(new ar(t, h, () => { d = !0, f() })), () => { } }(r, o, e, n))) } const Na = new be(e => e.complete()); function xa(e) { return e[e.length - 1] } function Yd(e, t = 0) { return sr((n, r) => { n.subscribe(new ar(r, o => pn(r, e, () => r.next(o), t), () => pn(r, e, () => r.complete(), t), o => pn(r, e, () => r.error(o), t))) }) } function Zd(e, t = 0) { return sr((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Jd(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new be(n => { pn(n, t, () => { const r = e[Symbol.asyncIterator](); pn(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function Fa(e, t) { return t ? function (e, t) { if (null != e) { if (Hd(e)) return function (e, t) { return On(e).pipe(Zd(t), Yd(t)) }(e, t); if (Bd(e)) return function (e, t) { return new be(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (jd(e)) return function (e, t) { return On(e).pipe(Zd(t), Yd(t)) }(e, t); if ($d(e)) return Jd(e, t); if (Wd(e)) return function (e, t) { return new be(n => { let r; return pn(n, t, () => { r = e[Gd](), pn(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => G(null == r ? void 0 : r.return) && r.return() }) }(e, t); if (zd(e)) return function (e, t) { return Jd(qd(e), t) }(e, t) } throw Ud(e) }(e, t) : On(e) } function UC(...e) { const t = function (e) { return function (e) { return e && G(e.schedule) }(xa(e)) ? e.pop() : void 0 }(e), n = function (e, t) { return "number" == typeof xa(e) ? e.pop() : 1 / 0 }(e), r = e; return r.length ? 1 === r.length ? On(r[0]) : function (e = 1 / 0) { return Kd(Rd, e) }(n)(Fa(r, t)) : Na } function Ra(e, t, ...n) { return !0 === t ? (e(), null) : !1 === t ? null : t(...n).pipe(sr((t, n) => { let r = 0; t.subscribe(new ar(n, o => { ++r <= 1 && (n.next(o), 1 <= r && n.complete()) })) })).subscribe(() => e()) } function z(e) { for (let t in e) if (e[t] === z) return t; throw Error("Could not find renamed property on target object.") } function Pa(e, t) { for (const n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n]) } function k(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(k).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function Oa(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const qC = z({ __forward_ref__: z }); function Z(e) { return e.__forward_ref__ = Z, e.toString = function () { return k(this()) }, e } function b(e) { return Xd(e) ? e() : e } function Xd(e) { return "function" == typeof e && e.hasOwnProperty(qC) && e.__forward_ref__ === Z } class Vn extends Error { constructor(t, n) { super(function (e, t) { return `${e ? `NG0${e}: ` : ""}${t}` }(t, n)), this.code = t } } function F(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function ke(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : F(e) } function Ni(e, t) { const n = t ? ` in ${t}` : ""; throw new Vn("201", `No provider for ${ke(e)} found${n}`) } function Xe(e, t) { null == e && function (e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function Q(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Lt(e) { return { providers: e.providers || [], imports: e.imports || [] } } function Xt(e) { return ef(e, xi) || ef(e, nf) } function ef(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function tf(e) { return e && (e.hasOwnProperty(ka) || e.hasOwnProperty(XC)) ? e[ka] : null } const xi = z({ \u0275prov: z }), ka = z({ \u0275inj: z }), nf = z({ ngInjectableDef: z }), XC = z({ ngInjectorDef: z }); var A = (() => ((A = A || {})[A.Default = 0] = "Default", A[A.Host = 1] = "Host", A[A.Self = 2] = "Self", A[A.SkipSelf = 4] = "SkipSelf", A[A.Optional = 8] = "Optional", A))(); let La; function gn(e) { const t = La; return La = e, t } function rf(e, t, n) { const r = Xt(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & A.Optional ? null : void 0 !== t ? t : void Ni(k(e), "Injector") } function mn(e) { return { toString: e }.toString() } var ut = (() => ((ut = ut || {})[ut.OnPush = 0] = "OnPush", ut[ut.Default = 1] = "Default", ut))(), et = (() => { return (e = et || (et = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", et; var e })(); const tE = "undefined" != typeof globalThis && globalThis, nE = "undefined" != typeof window && window, rE = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, W = tE || "undefined" != typeof global && global || nE || rE, ur = {}, K = [], Fi = z({ \u0275cmp: z }), Ba = z({ \u0275dir: z }), ja = z({ \u0275pipe: z }), of = z({ \u0275mod: z }), en = z({ \u0275fac: z }), fo = z({ __NG_ELEMENT_ID__: z }); let oE = 0; function ho(e) { return mn(() => { const n = {}, r = { type: e.type, providersResolver: null, decls: e.decls, vars: e.vars, factory: null, template: e.template || null, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: n, inputs: null, outputs: null, exportAs: e.exportAs || null, onPush: e.changeDetection === ut.OnPush, directiveDefs: null, pipeDefs: null, selectors: e.selectors || K, viewQuery: e.viewQuery || null, features: e.features || null, data: e.data || {}, encapsulation: e.encapsulation || et.Emulated, id: "c", styles: e.styles || K, _: null, setInput: null, schemas: e.schemas || null, tView: null }, o = e.directives, i = e.features, s = e.pipes; return r.id += oE++, r.inputs = lf(e.inputs, n), r.outputs = lf(e.outputs), i && i.forEach(a => a(r)), r.directiveDefs = o ? () => ("function" == typeof o ? o() : o).map(sf) : null, r.pipeDefs = s ? () => ("function" == typeof s ? s() : s).map(af) : null, r }) } function sf(e) { return Ie(e) || function (e) { return e[Ba] || null }(e) } function af(e) { return function (e) { return e[ja] || null }(e) } const uf = {}; function yn(e) { return mn(() => { const t = { type: e.type, bootstrap: e.bootstrap || K, declarations: e.declarations || K, imports: e.imports || K, exports: e.exports || K, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null }; return null != e.id && (uf[e.id] = e.type), t }) } function lf(e, t) { if (null == e) return ur; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } const R = ho; function Ie(e) { return e[Fi] || null } function lt(e, t) { const n = e[of] || null; if (!n && !0 === t) throw new Error(`Type ${k(e)} does not have '\u0275mod' property.`); return n } const O = 11, J = 20; function Bt(e) { return Array.isArray(e) && "object" == typeof e[1] } function wt(e) { return Array.isArray(e) && !0 === e[1] } function Ua(e) { return 0 != (8 & e.flags) } function Vi(e) { return 2 == (2 & e.flags) } function ki(e) { return 1 == (1 & e.flags) } function bt(e) { return null !== e.template } function cE(e) { return 0 != (512 & e[2]) } function Hn(e, t) { return e.hasOwnProperty(en) ? e[en] : null } class df { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function nt() { return ff } function ff(e) { return e.type.prototype.ngOnChanges && (e.setInput = pE), hE } function hE() { const e = pf(this), t = null == e ? void 0 : e.current; if (t) { const n = e.previous; if (n === ur) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function pE(e, t, n, r) { const o = pf(e) || function (e, t) { return e[hf] = t }(e, { previous: ur, current: null }), i = o.current || (o.current = {}), s = o.previous, a = this.declaredInputs[n], u = s[a]; i[a] = new df(u && u.currentValue, t, s === ur), e[r] = t } nt.ngInherit = !0; const hf = "__ngSimpleChanges__"; function pf(e) { return e[hf] || null } let qa; function ae(e) { return !!e.listen } const yf = { createRenderer: (e, t) => void 0 !== qa ? qa : "undefined" != typeof document ? document : void 0 }; function fe(e) { for (; Array.isArray(e);)e = e[0]; return e } function Li(e, t) { return fe(t[e]) } function ft(e, t) { return fe(t[e.index]) } function Qa(e, t) { return e.data[t] } function rt(e, t) { const n = t[e]; return Bt(n) ? n : n[0] } function Ka(e) { return 128 == (128 & e[2]) } function Dn(e, t) { return null == t ? null : e[t] } function Df(e) { e[18] = 0 } function Ya(e, t) { e[5] += t; let n = e, r = e[3]; for (; null !== r && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);)r[5] += t, n = r, r = r[3] } const S = { lFrame: Af(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function Cf() { return S.bindingsEnabled } function D() { return S.lFrame.lView } function H() { return S.lFrame.tView } function ge() { let e = Ef(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Ef() { return S.lFrame.currentTNode } function jt(e, t) { const n = S.lFrame; n.currentTNode = e, n.isParent = t } function Za() { return S.lFrame.isParent } function Bi() { return S.isInCheckNoChangesMode } function ji(e) { S.isInCheckNoChangesMode = e } function pr() { return S.lFrame.bindingIndex++ } function nn(e) { const t = S.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n } function NE(e, t) { const n = S.lFrame; n.bindingIndex = n.bindingRootIndex = e, Xa(t) } function Xa(e) { S.lFrame.currentDirectiveIndex = e } function tu(e) { S.lFrame.currentQueryIndex = e } function FE(e) { const t = e[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null } function Mf(e, t, n) { if (n & A.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & A.Host || (o = FE(i), null === o || (i = i[15], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = S.lFrame = If(); return r.currentTNode = t, r.lView = e, !0 } function Hi(e) { const t = If(), n = e[1]; S.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function If() { const e = S.lFrame, t = null === e ? null : e.child; return null === t ? Af(e) : t } function Af(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function Tf() { const e = S.lFrame; return S.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Sf = Tf; function $i() { const e = Tf(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Be() { return S.lFrame.selectedIndex } function Cn(e) { S.lFrame.selectedIndex = e } function Ui(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: l, ngOnDestroy: c } = i; s && (e.contentHooks || (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks || (e.contentHooks = [])).push(n, a), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, a)), u && (e.viewHooks || (e.viewHooks = [])).push(-n, u), l && ((e.viewHooks || (e.viewHooks = [])).push(n, l), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, l)), null != c && (e.destroyHooks || (e.destroyHooks = [])).push(n, c) } } function Gi(e, t, n) { Nf(e, t, 3, n) } function Wi(e, t, n, r) { (3 & e[2]) === n && Nf(e, t, n, r) } function nu(e, t) { let n = e[2]; (3 & n) === t && (n &= 2047, n += 1, e[2] = n) } function Nf(e, t, n, r) { const i = null != r ? r : -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[18] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[18] += 65536), (a < i || -1 == i) && (HE(e, n, t, u), e[18] = (4294901760 & e[18]) + u + 2), u++ } function HE(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) { e[2] += 2048; try { i.call(a) } finally { } } } else try { i.call(a) } finally { } } class _o { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function qi(e, t, n) { const r = ae(e); let o = 0; for (; o < n.length;) { const i = n[o]; if ("number" == typeof i) { if (0 !== i) break; o++; const s = n[o++], a = n[o++], u = n[o++]; r ? e.setAttribute(t, a, u, s) : t.setAttributeNS(s, a, u) } else { const s = i, a = n[++o]; ou(s) ? r && e.setProperty(t, s, a) : r ? e.setAttribute(t, s, a) : t.setAttribute(s, a), o++ } } return o } function xf(e) { return 3 === e || 4 === e || 6 === e } function ou(e) { return 64 === e.charCodeAt(0) } function zi(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || Ff(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function Ff(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function Rf(e) { return -1 !== e } function gr(e) { return 32767 & e } function mr(e, t) { let n = function (e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[15], n--; return r } let iu = !0; function Qi(e) { const t = iu; return iu = e, t } let zE = 0; function Co(e, t) { const n = au(e, t); if (-1 !== n) return n; const r = t[1]; r.firstCreatePass && (e.injectorIndex = t.length, su(r.data, e), su(t, null), su(r.blueprint, null)); const o = Ki(e, t), i = e.injectorIndex; if (Rf(o)) { const s = gr(o), a = mr(o, t), u = a[1].data; for (let l = 0; l < 8; l++)t[i + l] = a[s + l] | u[s + l] } return t[i + 8] = o, i } function su(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function au(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Ki(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { const i = o[1], s = i.type; if (r = 2 === s ? i.declTNode : 1 === s ? o[6] : null, null === r) return -1; if (n++, o = o[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function Yi(e, t, n) { !function (e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(fo) && (r = n[fo]), null == r && (r = n[fo] = zE++); const o = 255 & r; t.data[e + (o >> 5)] |= 1 << o }(e, t, n) } function Vf(e, t, n) { if (n & A.Optional) return e; Ni(t, "NodeInjector") } function kf(e, t, n, r) { if (n & A.Optional && void 0 === r && (r = null), 0 == (n & (A.Self | A.Host))) { const o = e[9], i = gn(void 0); try { return o ? o.get(t, r, n & A.Optional) : rf(t, r, n & A.Optional) } finally { gn(i) } } return Vf(r, t, n) } function Lf(e, t, n, r = A.Default, o) { if (null !== e) { const i = function (e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(fo) ? e[fo] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : YE : t }(n); if ("function" == typeof i) { if (!Mf(t, e, r)) return r & A.Host ? Vf(o, n, r) : kf(t, n, r, o); try { const s = i(r); if (null != s || r & A.Optional) return s; Ni(n) } finally { Sf() } } else if ("number" == typeof i) { let s = null, a = au(e, t), u = -1, l = r & A.Host ? t[16][6] : null; for ((-1 === a || r & A.SkipSelf) && (u = -1 === a ? Ki(e, t) : t[a + 8], -1 !== u && Hf(r, !1) ? (s = t[1], a = gr(u), t = mr(u, t)) : a = -1); -1 !== a;) { const c = t[1]; if (jf(i, a, c.data)) { const d = ZE(a, t, n, s, r, l); if (d !== Bf) return d } u = t[a + 8], -1 !== u && Hf(r, t[1].data[a + 8] === l) && jf(i, a, t) ? (s = c, a = gr(u), t = mr(u, t)) : a = -1 } } } return kf(t, n, r, o) } const Bf = {}; function YE() { return new yr(ge(), D()) } function ZE(e, t, n, r, o, i) { const s = t[1], a = s.data[e + 8], c = function (e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && bt(h) && h.type === n) return u } return null }(a, s, n, null == r ? Vi(a) && iu : r != s && 0 != (3 & a.type), o & A.Host && i === a); return null !== c ? Eo(t, s, c, a) : Bf } function Eo(e, t, n, r) { let o = e[n]; const i = t.data; if (function (e) { return e instanceof _o }(o)) { const s = o; s.resolving && function (e, t) { throw new Vn("200", `Circular dependency in DI detected for ${e}`) }(ke(i[n])); const a = Qi(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? gn(s.injectImpl) : null; Mf(e, r, A.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function (e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = ff(t); (n.preOrderHooks || (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== u && gn(u), Qi(a), s.resolving = !1, Sf() } } return o } function jf(e, t, n) { return !!(n[t + (e >> 5)] & 1 << e) } function Hf(e, t) { return !(e & A.Self || e & A.Host && t) } class yr { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return Lf(this._tNode, this._lView, t, r, n) } } function uu(e) { return Xd(e) ? () => { const t = uu(b(e)); return t && t() } : Hn(e) } const Dr = "__parameters__"; function $n(e, t, n) { return mn(() => { const r = function (e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, l, c) { const d = u.hasOwnProperty(Dr) ? u[Dr] : Object.defineProperty(u, Dr, { value: [] })[Dr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class $ { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = Q({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } toString() { return `InjectionToken ${this._desc}` } } function Ht(e, t) { e.forEach(n => Array.isArray(n) ? Ht(n, t) : t(n)) } function Ji(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Un(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function ot(e, t, n) { let r = Er(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function (e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (1 === o) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;)e[o] = e[o - 2], o--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function fu(e, t) { const n = Er(e, t); if (n >= 0) return e[1 | n] } function Er(e, t) { return function (e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) }(e, t, 1) } const Io = {}, pu = "__NG_DI_FLAG__", vr = "ngTempTokenPath", cv = /\n/gm, gu = "__source", mu = z({ provide: String, useValue: z }); let Ao; function wr(e) { const t = Ao; return Ao = e, t } function fv(e, t = A.Default) { if (void 0 === Ao) throw new Error("inject() must be called from an injection context"); return null === Ao ? rf(e, void 0, t) : Ao.get(e, t & A.Optional ? null : void 0, t) } function U(e, t = A.Default) { return (La || fv)(b(e), t) } function Gn(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = b(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new Error("Arguments array must have arguments."); let o, i = A.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = hv(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(U(o, i)) } else t.push(U(r)) } return t } function To(e, t) { return e[pu] = t, e.prototype[pu] = t, e } function hv(e) { return e[pu] } function qf(e, t, n, r) { const o = e[vr]; throw t[gu] && o.unshift(t[gu]), e.message = function (e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.substr(2) : e; let o = k(t); if (Array.isArray(t)) o = t.map(k).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : k(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(cv, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[vr] = null, e } const So = To($n("Inject", e => ({ token: e })), -1), $t = To($n("Optional"), 8), Wn = To($n("SkipSelf"), 4); const fh = "__ngContext__"; function Te(e, t) { e[fh] = t } function Mu(e) { const t = function (e) { return e[fh] || null }(e); return t ? Array.isArray(t) ? t : t.lView : null } function is(e) { return e.ngOriginalError } function sw(e, ...t) { e.error(...t) } class zn { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t), r = this._findContext(t), o = (e = t) && e.ngErrorLogger || sw; var e; o(this._console, "ERROR", t), n && o(this._console, "ORIGINAL ERROR", n), r && o(this._console, "ERROR CONTEXT", r) } _findContext(t) { return t ? t.ngDebugContext || this._findContext(is(t)) : null } _findOriginalError(t) { let n = t && is(t); for (; n && is(n);)n = is(n); return n || null } } const Eh = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(W))(); function Wt(e) { return e instanceof Function ? e() : e } var st = (() => ((st = st || {})[st.Important = 1] = "Important", st[st.DashCase = 2] = "DashCase", st))(); function Tu(e, t) { return undefined(e, t) } function Oo(e) { const t = e[3]; return wt(t) ? t[3] : t } function Su(e) { return Ih(e[13]) } function Nu(e) { return Ih(e[4]) } function Ih(e) { for (; null !== e && !wt(e);)e = e[4]; return e } function Ar(e, t, n, r, o) { if (null != r) { let i, s = !1; wt(r) ? i = r : Bt(r) && (s = !0, r = r[0]); const a = fe(r); 0 === e && null !== n ? null == o ? Fh(t, n, a) : Qn(t, n, a, o || null, !0) : 1 === e && null !== n ? Qn(t, n, a, o || null, !0) : 2 === e ? function (e, t, n) { const r = as(e, t); r && function (e, t, n, r) { ae(e) ? e.removeChild(t, n, r) : t.removeChild(n) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function (e, t, n, r, o) { const i = n[7]; i !== fe(n) && Ar(t, e, r, i, o); for (let a = 10; a < n.length; a++) { const u = n[a]; Vo(u[1], u, e, t, r, i) } }(t, e, i, n, o) } } function Fu(e, t, n) { return ae(e) ? e.createElement(t, n) : null === n ? e.createElement(t) : e.createElementNS(n, t) } function Th(e, t) { const n = e[9], r = n.indexOf(t), o = t[3]; 1024 & t[2] && (t[2] &= -1025, Ya(o, -1)), n.splice(r, 1) } function Ru(e, t) { if (e.length <= 10) return; const n = 10 + t, r = e[n]; if (r) { const o = r[17]; null !== o && o !== e && Th(o, r), t > 0 && (e[n - 1][4] = r[4]); const i = Un(e, 10 + t); !function (e, t) { Vo(e, t, t[O], 2, null, null), t[0] = null, t[6] = null }(r[1], r); const s = i[19]; null !== s && s.detachView(i[1]), r[3] = null, r[4] = null, r[2] &= -129 } return r } function Sh(e, t) { if (!(256 & t[2])) { const n = t[O]; ae(n) && n.destroyNode && Vo(e, t, n, 3, null, null), function (e) { let t = e[13]; if (!t) return Pu(e[1], e); for (; t;) { let n = null; if (Bt(t)) n = t[13]; else { const r = t[10]; r && (n = r) } if (!n) { for (; t && !t[4] && t !== e;)Bt(t) && Pu(t[1], t), t = t[3]; null === t && (t = e), Bt(t) && Pu(t[1], t), n = t && t[4] } t = n } }(t) } } function Pu(e, t) { if (!(256 & t[2])) { t[2] &= -129, t[2] |= 256, function (e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof _o)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; try { u.call(a) } finally { } } else try { i.call(o) } finally { } } } }(e, t), function (e, t) { const n = e.cleanup, r = t[7]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 1], a = "function" == typeof s ? s(t) : fe(t[s]), u = r[o = n[i + 2]], l = n[i + 3]; "boolean" == typeof l ? a.removeEventListener(n[i], u, l) : l >= 0 ? r[o = l]() : r[o = -l].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)r[i](); t[7] = null } }(e, t), 1 === t[1].type && ae(t[O]) && t[O].destroy(); const n = t[17]; if (null !== n && wt(t[3])) { n !== t[3] && Th(n, t); const r = t[19]; null !== r && r.detachView(e) } } } function Nh(e, t, n) { return function (e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const o = e.data[r.directiveStart].encapsulation; if (o === et.None || o === et.Emulated) return null } return ft(r, n) }(e, t.parent, n) } function Qn(e, t, n, r, o) { ae(e) ? e.insertBefore(t, n, r, o) : t.insertBefore(n, r, o) } function Fh(e, t, n) { ae(e) ? e.appendChild(t, n) : t.appendChild(n) } function Rh(e, t, n, r, o) { null !== r ? Qn(e, t, n, r, o) : Fh(e, t, n) } function as(e, t) { return ae(e) ? e.parentNode(t) : t.parentNode } let Vh = function (e, t, n) { return 40 & e.type ? ft(e, n) : null }; function us(e, t, n, r) { const o = Nh(e, r, t), i = t[O], a = function (e, t, n) { return Vh(e, t, n) }(r.parent || t[6], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Rh(i, o, n[u], a, !1); else Rh(i, o, n, a, !1) } function ls(e, t) { if (null !== t) { const n = t.type; if (3 & n) return ft(t, e); if (4 & n) return Vu(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return ls(e, r); { const o = e[t.index]; return wt(o) ? Vu(-1, o) : fe(o) } } if (32 & n) return Tu(t, e)() || fe(e[t.index]); { const r = Lh(e, t); return null !== r ? Array.isArray(r) ? r[0] : ls(Oo(e[16]), r) : ls(e, t.next) } } return null } function Lh(e, t) { return null !== t ? e[16][6].projection[t.projection] : null } function Vu(e, t) { const n = 10 + e + 1; if (n < t.length) { const r = t[n], o = r[1].firstChild; if (null !== o) return ls(r, o) } return t[7] } function ku(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && Te(fe(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & u) ku(e, t, n.child, r, o, i, !1), Ar(t, e, o, a, i); else if (32 & u) { const l = Tu(n, r); let c; for (; c = l();)Ar(t, e, o, c, i); Ar(t, e, o, a, i) } else 16 & u ? jh(e, t, r, n, o, i) : Ar(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function Vo(e, t, n, r, o, i) { ku(n, r, e.firstChild, t, o, i, !1) } function jh(e, t, n, r, o, i) { const s = n[16], u = s[6].projection[r.projection]; if (Array.isArray(u)) for (let l = 0; l < u.length; l++)Ar(t, e, o, u[l], i); else ku(e, t, u, s[3], o, i, !0) } function Hh(e, t, n) { ae(e) ? e.setAttribute(t, "style", n) : t.style.cssText = n } function Lu(e, t, n) { ae(e) ? "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) : t.className = n } function $h(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const Uh = "ng-template"; function Fw(e, t, n) { let r = 0; for (; r < e.length;) { let o = e[r++]; if (n && "class" === o) { if (o = e[r], -1 !== $h(o.toLowerCase(), t, 0)) return !0 } else if (1 === o) { for (; r < e.length && "string" == typeof (o = e[r++]);)if (o.toLowerCase() === t) return !0; return !1 } } return !1 } function Gh(e) { return 4 === e.type && e.value !== Uh } function Rw(e, t, n) { return t === (4 !== e.type || n ? e.value : Uh) } function Pw(e, t, n) { let r = 4; const o = e.attrs || [], i = function (e) { for (let t = 0; t < e.length; t++)if (xf(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !Rw(e, u, n) || "" === u && 1 === t.length) { if (It(r)) return !1; s = !0 } } else { const l = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!Fw(e.attrs, l, n)) { if (It(r)) return !1; s = !0 } continue } const d = Ow(8 & r ? "class" : u, o, Gh(e), n); if (-1 === d) { if (It(r)) return !1; s = !0; continue } if ("" !== l) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== $h(h, l, 0) || 2 & r && l !== f) { if (It(r)) return !1; s = !0 } } } } else { if (!s && !It(r) && !It(u)) return !1; if (s && It(u)) continue; s = !1, r = u | 1 & r } } return It(r) || s } function It(e) { return 0 == (1 & e) } function Ow(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function (e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Wh(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (Pw(e, t[r], n)) return !0; return !1 } function qh(e, t) { return e ? ":not(" + t.trim() + ")" : t } function jw(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !It(s) && (t += qh(i, o), o = ""), r = s, i = i || !It(r); n++ } return "" !== o && (t += qh(i, o)), t } const P = {}; function ko(e) { zh(H(), D(), Be() + e, Bi()) } function zh(e, t, n, r) { if (!r) if (3 == (3 & t[2])) { const i = e.preOrderCheckHooks; null !== i && Gi(t, i, n) } else { const i = e.preOrderHooks; null !== i && Wi(t, i, 0, n) } Cn(n) } function cs(e, t) { return e << 17 | t << 2 } function At(e) { return e >> 17 & 32767 } function Bu(e) { return 2 | e } function rn(e) { return (131068 & e) >> 2 } function ju(e, t) { return -131069 & e | t << 2 } function Hu(e) { return 1 | e } function rp(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const o = n[r], i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; tu(o), s.contentQueries(2, t[i], i) } } } function Lo(e, t, n, r, o, i, s, a, u, l) { const c = t.blueprint.slice(); return c[0] = o, c[2] = 140 | r, Df(c), c[3] = c[15] = e, c[8] = n, c[10] = s || e && e[10], c[O] = a || e && e[O], c[12] = u || e && e[12] || null, c[9] = l || e && e[9] || null, c[6] = i, c[16] = 2 == t.type ? e[16] : c, c } function Tr(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function (e, t, n, r, o) { const i = Ef(), s = Za(), u = e.data[t] = function (e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u)), u }(e, t, n, r, o), S.lFrame.inI18n && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function () { const e = S.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return jt(i, !0), i } function Sr(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function Bo(e, t, n) { Hi(t); try { const r = e.viewQuery; null !== r && rl(1, r, n); const o = e.template; null !== o && op(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && rp(e, t), e.staticViewQueries && rl(2, e.viewQuery, n); const i = e.components; null !== i && function (e, t) { for (let n = 0; n < t.length; n++)Db(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[2] &= -5, $i() } } function Nr(e, t, n, r) { const o = t[2]; if (256 == (256 & o)) return; Hi(t); const i = Bi(); try { Df(t), function (e) { S.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && op(e, t, n, 2, r); const s = 3 == (3 & o); if (!i) if (s) { const l = e.preOrderCheckHooks; null !== l && Gi(t, l, null) } else { const l = e.preOrderHooks; null !== l && Wi(t, l, 0, null), nu(t, 0) } if (function (e) { for (let t = Su(e); null !== t; t = Nu(t)) { if (!t[2]) continue; const n = t[9]; for (let r = 0; r < n.length; r++) { const o = n[r], i = o[3]; 0 == (1024 & o[2]) && Ya(i, 1), o[2] |= 1024 } } }(t), function (e) { for (let t = Su(e); null !== t; t = Nu(t))for (let n = 10; n < t.length; n++) { const r = t[n], o = r[1]; Ka(r) && Nr(o, r, o.template, r[8]) } }(t), null !== e.contentQueries && rp(e, t), !i) if (s) { const l = e.contentCheckHooks; null !== l && Gi(t, l) } else { const l = e.contentHooks; null !== l && Wi(t, l, 1), nu(t, 1) } !function (e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) Cn(~o); else { const i = o, s = n[++r], a = n[++r]; NE(s, i), a(2, t[i]) } } } finally { Cn(-1) } }(e, t); const a = e.components; null !== a && function (e, t) { for (let n = 0; n < t.length; n++)_b(e, t[n]) }(t, a); const u = e.viewQuery; if (null !== u && rl(2, u, r), !i) if (s) { const l = e.viewCheckHooks; null !== l && Gi(t, l) } else { const l = e.viewHooks; null !== l && Wi(t, l, 2), nu(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), i || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, Ya(t[3], -1)) } finally { $i() } } function Xw(e, t, n, r) { const o = t[10], i = !Bi(), s = function (e) { return 4 == (4 & e[2]) }(t); try { i && !s && o.begin && o.begin(), s && Bo(e, t, r), Nr(e, t, n, r) } finally { i && !s && o.end && o.end() } } function op(e, t, n, r, o) { const i = Be(), s = 2 & r; try { Cn(-1), s && t.length > J && zh(e, t, J, Bi()), n(r, o) } finally { Cn(i) } } function Ku(e, t, n) { !Cf() || (function (e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; e.firstCreatePass || Co(n, t), Te(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], l = bt(u); l && hb(t, n, u); const c = Eo(t, e, a, n); Te(c, t), null !== s && pb(0, a - o, c, u, 0, s), l && (rt(n.index, t)[8] = c) } }(e, t, n, ft(n, t)), 128 == (128 & n.flags) && function (e, t, n) { const r = n.directiveStart, o = n.directiveEnd, s = n.index, a = S.lFrame.currentDirectiveIndex; try { Cn(s); for (let u = r; u < o; u++) { const l = e.data[u], c = t[u]; Xa(u), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && hp(l, c) } } finally { Cn(-1), Xa(a) } }(e, t, n)) } function Yu(e, t, n = ft) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function sp(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = hs(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function hs(e, t, n, r, o, i, s, a, u, l) { const c = J + r, d = c + o, f = function (e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : P); return n }(c, d), h = "function" == typeof l ? l() : l; return f[1] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: h, incompleteFirstPass: !1 } } function cp(e, t, n) { for (let r in e) if (e.hasOwnProperty(r)) { const o = e[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(t, o) : n[r] = [t, o] } return n } function Zu(e, t, n, r) { let o = !1; if (Cf()) { const i = function (e, t, n) { const r = e.directiveRegistry; let o = null; if (r) for (let i = 0; i < r.length; i++) { const s = r[i]; Wh(n, s.selectors, !1) && (o || (o = []), Yi(Co(n, t), e, s.type), bt(s) ? (pp(e, n), o.unshift(s)) : o.push(s)) } return o }(e, t, n), s = null === r ? null : { "": -1 }; if (null !== i) { o = !0, gp(n, e.data.length, i.length); for (let c = 0; c < i.length; c++) { const d = i[c]; d.providersResolver && d.providersResolver(d) } let a = !1, u = !1, l = Sr(e, t, i.length, null); for (let c = 0; c < i.length; c++) { const d = i[c]; n.mergedAttrs = zi(n.mergedAttrs, d.hostAttrs), mp(e, n, t, l, d), fb(l, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), a = !0), !u && (f.ngOnChanges || f.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), u = !0), l++ } !function (e, t) { const r = t.directiveEnd, o = e.data, i = t.attrs, s = []; let a = null, u = null; for (let l = t.directiveStart; l < r; l++) { const c = o[l], d = c.inputs, f = null === i || Gh(t) ? null : gb(d, i); s.push(f), a = cp(d, l, a), u = cp(c.outputs, l, u) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = u }(e, n) } s && function (e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new Vn("301", `Export of name '${t[o + 1]}' not found!`); r.push(t[o], i) } } }(n, r, s) } return n.mergedAttrs = zi(n.mergedAttrs, n.attrs), o } function fp(e, t, n, r, o, i) { const s = i.hostBindings; if (s) { let a = e.hostBindingOpCodes; null === a && (a = e.hostBindingOpCodes = []); const u = ~t.index; (function (e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != u && a.push(u), a.push(r, o, s) } } function hp(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function pp(e, t) { t.flags |= 2, (e.components || (e.components = [])).push(t.index) } function fb(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; bt(t) && (n[""] = e) } } function gp(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function mp(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = Hn(o.type)), s = new _o(i, bt(o), null); e.blueprint[r] = s, n[r] = s, fp(e, t, 0, r, Sr(e, n, o.hostVars, P), o) } function hb(e, t, n) { const r = ft(t, e), o = sp(n), i = e[10], s = ps(e, Lo(e, o, null, n.onPush ? 64 : 16, r, t, i, i.createRenderer(r, n), null, null)); e[t.index] = s } function pb(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let u = 0; u < s.length;) { const l = s[u++], c = s[u++], d = s[u++]; null !== a ? r.setInput(n, d, l, c) : n[c] = d } } } function gb(e, t) { let n = null, r = 0; for (; r < t.length;) { const o = t[r]; if (0 !== o) if (5 !== o) { if ("number" == typeof o) break; e.hasOwnProperty(o) && (null === n && (n = []), n.push(o, e[o], t[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function yp(e, t, n, r) { return new Array(e, !0, !1, t, null, 0, r, n, null, null) } function _b(e, t) { const n = rt(t, e); if (Ka(n)) { const r = n[1]; 80 & n[2] ? Nr(r, n, r.template, n[8]) : n[5] > 0 && Xu(n) } } function Xu(e) { for (let r = Su(e); null !== r; r = Nu(r))for (let o = 10; o < r.length; o++) { const i = r[o]; if (1024 & i[2]) { const s = i[1]; Nr(s, i, s.template, i[8]) } else i[5] > 0 && Xu(i) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = rt(n[r], e); Ka(o) && o[5] > 0 && Xu(o) } } function Db(e, t) { const n = rt(t, e), r = n[1]; (function (e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), Bo(r, n, n[8]) } function ps(e, t) { return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t } function el(e) { for (; e;) { e[2] |= 64; const t = Oo(e); if (cE(e) && !t) return e; e = t } return null } function nl(e, t, n) { const r = t[10]; r.begin && r.begin(); try { Nr(e, t, e.template, n) } catch (o) { throw vp(t, o), o } finally { r.end && r.end() } } function _p(e) { !function (e) { for (let t = 0; t < e.components.length; t++) { const n = e.components[t], r = Mu(n), o = r[1]; Xw(o, r, o.template, n) } }(e[8]) } function rl(e, t, n) { tu(0), t(e, n) } const bb = (() => Promise.resolve(null))(); function Dp(e) { return e[7] || (e[7] = []) } function Cp(e) { return e.cleanup || (e.cleanup = []) } function vp(e, t) { const n = e[9], r = n ? n.get(zn, null) : null; r && r.handleError(t) } function wp(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], u = t[s], l = e.data[s]; null !== l.setInput ? l.setInput(u, o, r, a) : u[a] = o } } function sn(e, t, n) { const r = Li(t, e); !function (e, t, n) { ae(e) ? e.setValue(t, n) : t.textContent = n }(e[O], r, n) } function gs(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = Oa(o, a) : 2 == i && (r = Oa(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } const jo = new $("INJECTOR", -1); class bp { get(t, n = Io) { if (n === Io) { const r = new Error(`NullInjectorError: No provider for ${k(t)}!`); throw r.name = "NullInjectorError", r } return n } } const Ho = new $("Set Injector scope."), $o = {}, Ab = {}; let ol; function Mp() { return void 0 === ol && (ol = new bp), ol } function Ip(e, t = null, n = null, r) { return new Sb(e, n, t || Mp(), r) } class Sb { constructor(t, n, r, o = null) { this.parent = r, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const i = []; n && Ht(n, a => this.processProvider(a, t, n)), Ht([t], a => this.processInjectorType(a, [], i)), this.records.set(jo, xr(void 0, this)); const s = this.records.get(Ho); this.scope = null != s ? s.value : null, this.source = o || ("object" == typeof t ? null : k(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, n = Io, r = A.Default) { this.assertNotDestroyed(); const o = wr(this), i = gn(void 0); try { if (!(r & A.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = ("function" == typeof (e = t) || "object" == typeof e && e instanceof $) && Xt(t); a = u && this.injectableDefInScope(u) ? xr(il(t), $o) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & A.Self ? Mp() : this.parent).get(t, n = r & A.Optional && n === Io ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[vr] = s[vr] || []).unshift(k(t)), o) throw s; return qf(s, t, "R3InjectorError", this.source) } throw s } finally { gn(i), wr(o) } var e } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((r, o) => t.push(k(o))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, n, r) { if (!(t = b(t))) return !1; let o = tf(t); const i = null == o && t.ngModule || void 0, s = void 0 === i ? t : i, a = -1 !== r.indexOf(s); if (void 0 !== i && (o = tf(i)), null == o) return !1; if (null != o.imports && !a) { let c; r.push(s); try { Ht(o.imports, d => { this.processInjectorType(d, n, r) && (void 0 === c && (c = []), c.push(d)) }) } finally { } if (void 0 !== c) for (let d = 0; d < c.length; d++) { const { ngModule: f, providers: h } = c[d]; Ht(h, p => this.processProvider(p, f, h || K)) } } this.injectorDefTypes.add(s); const u = Hn(s) || (() => new s); this.records.set(s, xr(u, $o)); const l = o.providers; if (null != l && !a) { const c = t; Ht(l, d => this.processProvider(d, c, l)) } return void 0 !== i && void 0 !== t.providers } processProvider(t, n, r) { let o = Fr(t = b(t)) ? t : b(t && t.provide); const i = (e = t, Tp(e) ? xr(void 0, e.useValue) : xr(Ap(e), $o)); var e; if (Fr(t) || !0 !== t.multi) this.records.get(o); else { let s = this.records.get(o); s || (s = xr(void 0, $o, !0), s.factory = () => Gn(s.multi), this.records.set(o, s)), o = t, s.multi.push(t) } this.records.set(o, i) } hydrate(t, n) { return n.value === $o && (n.value = Ab, n.value = n.factory()), "object" == typeof n.value && n.value && null !== (e = n.value) && "object" == typeof e && "function" == typeof e.ngOnDestroy && this.onDestroy.add(n.value), n.value; var e } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = b(t.providedIn); return "string" == typeof n ? "any" === n || n === this.scope : this.injectorDefTypes.has(n) } } function il(e) { const t = Xt(e), n = null !== t ? t.factory : Hn(e); if (null !== n) return n; if (e instanceof $) throw new Error(`Token ${k(e)} is missing a \u0275prov definition.`); if (e instanceof Function) return function (e) { const t = e.length; if (t > 0) { const r = function (e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"); throw new Error(`Can't resolve all parameters for ${k(e)}: (${r.join(", ")}).`) } const n = function (e) { const t = e && (e[xi] || e[nf]); if (t) { const n = function (e) { if (e.hasOwnProperty("name")) return e.name; const t = ("" + e).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(e); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t } return null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new Error("unreachable") } function Ap(e, t, n) { let r; if (Fr(e)) { const o = b(e); return Hn(o) || il(o) } if (Tp(e)) r = () => b(e.useValue); else if (function (e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Gn(e.deps || [])); else if (function (e) { return !(!e || !e.useExisting) }(e)) r = () => U(b(e.useExisting)); else { const o = b(e && (e.useClass || e.provide)); if (!function (e) { return !!e.deps }(e)) return Hn(o) || il(o); r = () => new o(...Gn(e.deps)) } return r } function xr(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Tp(e) { return null !== e && "object" == typeof e && mu in e } function Fr(e) { return "function" == typeof e } const Sp = function (e, t, n) { return function (e, t = null, n = null, r) { const o = Ip(e, t, n, r); return o._resolveInjectorDefTypes(), o }({ name: n }, t, e, n) }; let X = (() => { class e { static create(n, r) { return Array.isArray(n) ? Sp(n, r, "") : Sp(n.providers, n.parent, n.name || "") } } return e.THROW_IF_NOT_FOUND = Io, e.NULL = new bp, e.\u0275prov = Q({ token: e, providedIn: "any", factory: () => U(jo) }), e.__NG_ELEMENT_ID__ = -1, e })(); function Yb(e, t) { Ui(Mu(e)[1], ge()) } function re(e) { let t = function (e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), n = !0; const r = [e]; for (; t;) { let o; if (bt(e)) o = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new Error("Directives cannot inherit Components"); o = t.\u0275dir } if (o) { if (n) { r.push(o); const s = e; s.inputs = dl(e.inputs), s.declaredInputs = dl(e.declaredInputs), s.outputs = dl(e.outputs); const a = o.hostBindings; a && e0(e, a); const u = o.viewQuery, l = o.contentQueries; if (u && Jb(e, u), l && Xb(e, l), Pa(e.inputs, o.inputs), Pa(e.declaredInputs, o.declaredInputs), Pa(e.outputs, o.outputs), bt(o) && o.data.animation) { const c = e.data; c.animation = (c.animation || []).concat(o.data.animation) } } const i = o.features; if (i) for (let s = 0; s < i.length; s++) { const a = i[s]; a && a.ngInherit && a(e), a === re && (n = !1) } } t = Object.getPrototypeOf(t) } !function (e) { let t = 0, n = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.hostVars = t += o.hostVars, o.hostAttrs = zi(o.hostAttrs, n = zi(n, o.hostAttrs)) } }(r) } function dl(e) { return e === ur ? {} : e === K ? [] : e } function Jb(e, t) { const n = e.viewQuery; e.viewQuery = n ? (r, o) => { t(r, o), n(r, o) } : t } function Xb(e, t) { const n = e.contentQueries; e.contentQueries = n ? (r, o, i) => { t(r, o, i), n(r, o, i) } : t } function e0(e, t) { const n = e.hostBindings; e.hostBindings = n ? (r, o) => { t(r, o), n(r, o) } : t } let ms = null; function Rr() { if (!ms) { const e = W.Symbol; if (e && e.iterator) ms = e.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < t.length; ++n) { const r = t[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (ms = r) } } } return ms } function Go(e) { return !!fl(e) && (Array.isArray(e) || !(e instanceof Map) && Rr() in e) } function fl(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function Se(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function ys(e, t, n, r, o) { const i = function (e, t, n, r) { const o = Se(e, t, n); return Se(e, t + 1, r) || o }(e, t, n, r); return Se(e, t + 2, o) || i } function kr(e, t, n, r, o, i, s, a) { const l = ys(e, S.lFrame.bindingIndex, n, o, s); return nn(3), l ? t + F(n) + r + F(o) + i + F(s) + a : P } function C(e, t = A.Default) { const n = D(); return null === n ? U(e, t) : Lf(ge(), n, b(e), t) } function qo(e, t, n) { const r = D(); return Se(r, pr(), t) && function (e, t, n, r, o, i, s, a) { const u = ft(t, n); let c, l = t.inputs; !a && null != l && (c = l[r]) ? (wp(e, n, c, r, o), Vi(t) && function (e, t) { const n = rt(t, e); 16 & n[2] || (n[2] |= 64) }(n, t.index)) : 3 & t.type && (r = function (e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, ae(i) ? i.setProperty(u, r, o) : ou(r) || (u.setProperty ? u.setProperty(r, o) : u[r] = o)) }(H(), function () { const e = S.lFrame; return Qa(e.tView, e.selectedIndex) }(), r, e, t, r[O], n, !1), qo } function yl(e, t, n, r, o) { const s = o ? "class" : "style"; wp(e, n, t.inputs[s], s, r) } function Qe(e, t, n, r) { const o = D(), i = H(), s = J + e, a = o[O], u = o[s] = Fu(a, t, S.lFrame.currentNamespace), l = i.firstCreatePass ? function (e, t, n, r, o, i, s) { const a = t.consts, l = Tr(t, e, 2, o, Dn(a, i)); return Zu(t, n, l, Dn(a, s)), null !== l.attrs && gs(l, l.attrs, !1), null !== l.mergedAttrs && gs(l, l.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, l), l }(s, i, o, 0, t, n, r) : i.data[s]; jt(l, !0); const c = l.mergedAttrs; null !== c && qi(a, u, c); const d = l.classes; null !== d && Lu(a, u, d); const f = l.styles; null !== f && Hh(a, u, f), 64 != (64 & l.flags) && us(i, o, u, l), 0 === S.lFrame.elementDepthCount && Te(u, o), S.lFrame.elementDepthCount++, ki(l) && (Ku(i, o, l), function (e, t, n) { if (Ua(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } }(i, l, o)), null !== r && Yu(o, l) } function Ke() { let e = ge(); Za() ? S.lFrame.isParent = !1 : (e = e.parent, jt(e, !1)); const t = e; S.lFrame.elementDepthCount--; const n = H(); n.firstCreatePass && (Ui(n, e), Ua(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function (e) { return 0 != (16 & e.flags) }(t) && yl(n, t, D(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function (e) { return 0 != (32 & e.flags) }(t) && yl(n, t, D(), t.stylesWithoutHost, !1) } function _l(e, t, n, r) { Qe(e, t, n, r), Ke() } function Ds(e) { return !!e && "function" == typeof e.then } const Dl = function (e) { return !!e && "function" == typeof e.subscribe }; function Ye(e, t, n, r) { const o = D(), i = H(), s = ge(); return function (e, t, n, r, o, i, s, a) { const u = ki(r), c = e.firstCreatePass && Cp(e), d = t[8], f = Dp(t); let h = !0; if (3 & r.type || a) { const g = ft(r, t), _ = a ? a(g) : g, y = f.length, w = a ? M => a(fe(M[r.index])) : r.index; if (ae(n)) { let M = null; if (!a && u && (M = function (e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[7], u = o[i + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== M) (M.__ngLastListenerFn__ || M).__ngNextListenerFn__ = i, M.__ngLastListenerFn__ = i, h = !1; else { i = Cl(r, t, d, i, !1); const L = n.listen(_, o, i); f.push(i, L), c && c.push(o, w, y, y + 1) } } else i = Cl(r, t, d, i, !0), _.addEventListener(o, i, s), f.push(i), c && c.push(o, w, y, s) } else i = Cl(r, t, d, i, !1); const p = r.outputs; let m; if (h && null !== p && (m = p[o])) { const g = m.length; if (g) for (let _ = 0; _ < g; _ += 2) { const De = t[m[_]][m[_ + 1]].subscribe(i), Ct = f.length; f.push(i, De), c && c.push(o, r.index, Ct, -(Ct + 1)) } } }(i, o, o[O], s, e, t, !!n, r), Ye } function Dg(e, t, n, r) { try { return !1 !== n(r) } catch (o) { return vp(e, o), !1 } } function Cl(e, t, n, r, o) { return function i(s) { if (s === Function) return r; const a = 2 & e.flags ? rt(e.index, t) : t; 0 == (32 & t[2]) && el(a); let u = Dg(t, 0, r, s), l = i.__ngNextListenerFn__; for (; l;)u = Dg(t, 0, l, s) && u, l = l.__ngNextListenerFn__; return o && !1 === u && (s.preventDefault(), s.returnValue = !1), u } } function Sg(e, t, n, r, o) { const i = e[n + 1], s = null === t; let a = r ? At(i) : rn(i), u = !1; for (; 0 !== a && (!1 === u || s);) { const c = e[a + 1]; G0(e[a], t) && (u = !0, e[a + 1] = r ? Hu(c) : Bu(c)), a = r ? At(c) : rn(c) } u && (e[n + 1] = r ? Bu(i) : Hu(i)) } function G0(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && Er(e, t) >= 0 } function Cs(e, t) { return function (e, t, n, r) { const o = D(), i = H(), s = nn(2); i.firstUpdatePass && function (e, t, n, r) { const o = e.data; if (null === o[n + 1]) { const i = o[Be()], s = function (e, t) { return t >= e.expandoStartIndex }(e, n); (function (e, t) { return 0 != (e.flags & (t ? 16 : 32)) })(i, r) && null === t && !s && (t = !1), t = function (e, t, n, r) { const o = function (e) { const t = S.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === o) 0 === (r ? t.classBindings : t.styleBindings) && (n = zo(n = vl(null, e, t, n, r), t.attrs, r), i = null); else { const s = t.directiveStylingLast; if (-1 === s || e[s] !== o) if (n = vl(o, e, t, n, r), null === i) { let u = function (e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== rn(r)) return e[At(r)] }(e, t, r); void 0 !== u && Array.isArray(u) && (u = vl(null, e, t, u[1], r), u = zo(u, t.attrs, r), function (e, t, n, r) { e[At(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, u)) } else i = function (e, t, n) { let r; const o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++)r = zo(r, e[i].hostAttrs, n); return zo(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(o, i, t, r), function (e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = At(s), u = rn(s); e[r] = n; let c, l = !1; if (Array.isArray(n)) { const d = n; c = d[1], (null === c || Er(d, c) > 0) && (l = !0) } else c = n; if (o) if (0 !== u) { const f = At(e[a + 1]); e[r + 1] = cs(f, a), 0 !== f && (e[f + 1] = ju(e[f + 1], r)), e[a + 1] = function (e, t) { return 131071 & e | t << 17 }(e[a + 1], r) } else e[r + 1] = cs(a, 0), 0 !== a && (e[a + 1] = ju(e[a + 1], r)), a = r; else e[r + 1] = cs(u, 0), 0 === a ? a = r : e[u + 1] = ju(e[u + 1], r), u = r; l && (e[r + 1] = Bu(e[r + 1])), Sg(e, c, r, !0), Sg(e, c, r, !1), function (e, t, n, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && Er(i, t) >= 0 && (n[r + 1] = Hu(n[r + 1])) }(t, c, e, r, i), s = cs(a, u), i ? t.classBindings = s : t.styleBindings = s }(o, i, t, n, s, r) } }(i, e, s, r), t !== P && Se(o, s, t) && function (e, t, n, r, o, i, s, a) { if (!(3 & t.type)) return; const u = e.data, l = u[a + 1]; Es(function (e) { return 1 == (1 & e) }(l) ? Hg(u, t, n, o, rn(l), s) : void 0) || (Es(i) || function (e) { return 2 == (2 & e) }(l) && (i = Hg(u, null, n, o, a, s)), function (e, t, n, r, o) { const i = ae(e); if (t) o ? i ? e.addClass(n, r) : n.classList.add(r) : i ? e.removeClass(n, r) : n.classList.remove(r); else { let s = -1 === r.indexOf("-") ? void 0 : st.DashCase; if (null == o) i ? e.removeStyle(n, r, s) : n.style.removeProperty(r); else { const a = "string" == typeof o && o.endsWith("!important"); a && (o = o.slice(0, -10), s |= st.Important), i ? e.setStyle(n, r, o, s) : n.style.setProperty(r, o, a ? "important" : "") } } }(r, s, Li(Be(), n), o, i)) }(i, i.data[Be()], o, o[O], e, o[s + 1] = function (e, t) { return null == e || ("string" == typeof t ? e += t : "object" == typeof e && (e = k(function (e) { return e instanceof class { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } ? e.changingThisBreaksApplicationSecurity : e }(e)))), e }(t, n), r, s) }(e, t, null, !0), Cs } function vl(e, t, n, r, o) { let i = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (i = t[a], r = zo(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function zo(e, t, n) { const r = n ? 1 : 2; let o = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), ot(e, s, !!n || t[++i])) } return void 0 === e ? null : e } function Hg(e, t, n, r, o, i) { const s = null === t; let a; for (; o > 0;) { const u = e[o], l = Array.isArray(u), c = l ? u[1] : u, d = null === c; let f = n[o + 1]; f === P && (f = d ? K : void 0); let h = d ? fu(f, r) : c === r ? f : void 0; if (l && !Es(h) && (h = fu(u, r)), Es(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? At(p) : rn(p) } if (null !== t) { let u = i ? t.residualClasses : t.residualStyles; null != u && (a = fu(u, r)) } return a } function Es(e) { return void 0 !== e } function ln(e, t = "") { const n = D(), r = H(), o = e + J, i = r.firstCreatePass ? Tr(r, o, 1, t, null) : r.data[o], s = n[o] = function (e, t) { return ae(e) ? e.createText(t) : e.createTextNode(t) }(n[O], t); us(r, n, s, i), jt(i, !1) } function vs(e) { return wl("", e, ""), vs } function wl(e, t, n) { const r = D(), o = function (e, t, n, r) { return Se(e, pr(), n) ? t + F(n) + r : P }(r, e, t, n); return o !== P && sn(r, Be(), o), wl } function bl(e, t, n, r, o, i, s) { const a = D(), u = kr(a, e, t, n, r, o, i, s); return u !== P && sn(a, Be(), u), bl } const Yn = void 0; var MM = ["en", [["a", "p"], ["AM", "PM"], Yn], [["AM", "PM"], Yn, Yn], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Yn, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Yn, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Yn, "{1} 'at' {0}", Yn], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (e) { const n = Math.floor(Math.abs(e)), r = e.toString().replace(/^[^.]*\.?/, "").length; return 1 === n && 0 === r ? 1 : 5 }]; let Wr = {}; function um(e) { return e in Wr || (Wr[e] = W.ng && W.ng.common && W.ng.common.locales && W.ng.common.locales[e]), Wr[e] } var v = (() => ((v = v || {})[v.LocaleId = 0] = "LocaleId", v[v.DayPeriodsFormat = 1] = "DayPeriodsFormat", v[v.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", v[v.DaysFormat = 3] = "DaysFormat", v[v.DaysStandalone = 4] = "DaysStandalone", v[v.MonthsFormat = 5] = "MonthsFormat", v[v.MonthsStandalone = 6] = "MonthsStandalone", v[v.Eras = 7] = "Eras", v[v.FirstDayOfWeek = 8] = "FirstDayOfWeek", v[v.WeekendRange = 9] = "WeekendRange", v[v.DateFormat = 10] = "DateFormat", v[v.TimeFormat = 11] = "TimeFormat", v[v.DateTimeFormat = 12] = "DateTimeFormat", v[v.NumberSymbols = 13] = "NumberSymbols", v[v.NumberFormats = 14] = "NumberFormats", v[v.CurrencyCode = 15] = "CurrencyCode", v[v.CurrencySymbol = 16] = "CurrencySymbol", v[v.CurrencyName = 17] = "CurrencyName", v[v.Currencies = 18] = "Currencies", v[v.Directionality = 19] = "Directionality", v[v.PluralCase = 20] = "PluralCase", v[v.ExtraData = 21] = "ExtraData", v))(); const ws = "en-US"; let lm = ws; function Al(e, t, n, r, o) { if (e = b(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)Al(e[i], t, n, r, o); else { const i = H(), s = D(); let a = Fr(e) ? e : b(e.provide), u = Ap(e); const l = ge(), c = 1048575 & l.providerIndexes, d = l.directiveStart, f = l.providerIndexes >> 20; if (Fr(e) || !e.multi) { const h = new _o(u, o, C), p = Sl(a, t, o ? c : c + f, d); -1 === p ? (Yi(Co(l, s), i, a), Tl(i, e, t.length), t.push(a), l.directiveStart++, l.directiveEnd++, o && (l.providerIndexes += 1048576), n.push(h), s.push(h)) : (n[p] = h, s[p] = h) } else { const h = Sl(a, t, c + f, d), p = Sl(a, t, c, c + f), m = h >= 0 && n[h], g = p >= 0 && n[p]; if (o && !g || !o && !m) { Yi(Co(l, s), i, a); const _ = function (e, t, n, r, o) { const i = new _o(e, n, C); return i.multi = [], i.index = t, i.componentProviders = 0, Rm(i, o, r && !n), i }(o ? wI : vI, n.length, o, r, u); !o && g && (n[p].providerFactory = _), Tl(i, e, t.length, 0), t.push(a), l.directiveStart++, l.directiveEnd++, o && (l.providerIndexes += 1048576), n.push(_), s.push(_) } else Tl(i, e, h > -1 ? h : p, Rm(n[o ? p : h], u, !o && r)); !o && r && g && n[p].componentProviders++ } } } function Tl(e, t, n, r) { const o = Fr(t); if (o || function (e) { return !!e.useClass }(t)) { const s = (t.useClass || t).prototype.ngOnDestroy; if (s) { const a = e.destroyHooks || (e.destroyHooks = []); if (!o && t.multi) { const u = a.indexOf(n); -1 === u ? a.push(n, [r, s]) : a[u + 1].push(r, s) } else a.push(n, s) } } } function Rm(e, t, n) { return n && e.componentProviders++, e.multi.push(t) - 1 } function Sl(e, t, n, r) { for (let o = n; o < r; o++)if (t[o] === e) return o; return -1 } function vI(e, t, n, r) { return Nl(this.multi, []) } function wI(e, t, n, r) { const o = this.multi; let i; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Eo(n, n[1], this.providerFactory.index, r); i = a.slice(0, s), Nl(o, i); for (let u = s; u < a.length; u++)i.push(a[u]) } else i = [], Nl(o, i); return i } function Nl(e, t) { for (let n = 0; n < e.length; n++)t.push((0, e[n])()); return t } function oe(e, t = []) { return n => { n.providersResolver = (r, o) => function (e, t, n) { const r = H(); if (r.firstCreatePass) { const o = bt(e); Al(n, r.data, r.blueprint, o, !0), Al(t, r.data, r.blueprint, o, !1) } }(r, o ? o(e) : e, t) } } class Pm { } const Vm = "ngComponent"; class II { resolveComponentFactory(t) { throw function (e) { const t = Error(`No component factory found for ${k(e)}. Did you add it to @NgModule.entryComponents?`); return t[Vm] = e, t }(t) } } let zr = (() => { class e { } return e.NULL = new II, e })(); function Ts(...e) { } function Qr(e, t) { return new Ne(ft(e, t)) } const SI = function () { return Qr(ge(), D()) }; let Ne = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = SI, e })(); class Ss { } let Zn = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => xI(), e })(); const xI = function () { const e = D(), n = rt(ge().index, e); return function (e) { return e[O] }(Bt(n) ? n : e) }; let Fl = (() => { class e { } return e.\u0275prov = Q({ token: e, providedIn: "root", factory: () => null }), e })(); class Ns { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Lm = new Ns("13.0.0"), Kr = {}; function xs(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(fe(i)), wt(i)) for (let a = 10; a < i.length; a++) { const u = i[a], l = u[1].firstChild; null !== l && xs(u[1], u, l, r) } const s = n.type; if (8 & s) xs(e, t, n.child, r); else if (32 & s) { const a = Tu(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = Lh(t, n); if (Array.isArray(a)) r.push(...a); else { const u = Oo(t[16]); xs(u[1], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class Jo { constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, n = t[1]; return xs(n, t, n.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (wt(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (Ru(t, r), Un(n, r)) } this._attachedToViewContainer = !1 } Sh(this._lView[1], this._lView) } onDestroy(t) { !function (e, t, n, r) { const o = Dp(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && Cp(e).push(r, o.length - 1)) }(this._lView[1], this._lView, null, t) } markForCheck() { el(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { nl(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (e, t, n) { ji(!0); try { nl(e, t, n) } finally { ji(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, Vo(this._lView[1], t = this._lView, t[O], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class PI extends Jo { constructor(t) { super(t), this._view = t } detectChanges() { _p(this._view) } checkNoChanges() { !function (e) { ji(!0); try { _p(e) } finally { ji(!1) } }(this._view) } get context() { return null } } class Bm extends zr { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = Ie(t); return new Rl(n, this.ngModule) } } function jm(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } const VI = new $("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Eh }); class Rl extends Pm { constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = t.selectors.map(jw).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return jm(this.componentDef.inputs) } get outputs() { return jm(this.componentDef.outputs) } create(t, n, r, o) { const i = (o = o || this.ngModule) ? function (e, t) { return { get: (n, r, o) => { const i = e.get(n, Kr, o); return i !== Kr || r === Kr ? i : t.get(n, r, o) } } }(t, o.injector) : t, s = i.get(Ss, yf), a = i.get(Fl, null), u = s.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = r ? function (e, t, n) { if (ae(e)) return e.selectRootElement(t, n === et.ShadowDom); let r = "string" == typeof t ? e.querySelector(t) : t; return r.textContent = "", r }(u, r, this.componentDef.encapsulation) : Fu(s.createRenderer(null, this.componentDef), l, function (e) { const t = e.toLowerCase(); return "svg" === t ? "http://www.w3.org/2000/svg" : "math" === t ? "http://www.w3.org/1998/MathML/" : null }(l)), d = this.componentDef.onPush ? 576 : 528, f = function (e, t) { return { components: [], scheduler: e || Eh, clean: bb, playerHandler: t || null, flags: 0 } }(), h = hs(0, null, null, 1, 0, null, null, null, null, null), p = Lo(null, h, f, d, null, null, s, u, a, i); let m, g; Hi(p); try { const _ = function (e, t, n, r, o, i) { const s = n[1]; n[20] = e; const u = Tr(s, 20, 2, "#host", null), l = u.mergedAttrs = t.hostAttrs; null !== l && (gs(u, l, !0), null !== e && (qi(o, e, l), null !== u.classes && Lu(o, e, u.classes), null !== u.styles && Hh(o, e, u.styles))); const c = r.createRenderer(e, t), d = Lo(n, sp(t), null, t.onPush ? 64 : 16, n[20], u, r, c, i || null, null); return s.firstCreatePass && (Yi(Co(u, n), s, t.type), pp(s, u), gp(u, n.length, 1)), ps(n, d), n[20] = d }(c, this.componentDef, p, s, u); if (c) if (r) qi(u, c, ["ng-version", Lm.full]); else { const { attrs: y, classes: w } = function (e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!It(o)) break; o = i } r++ } return { attrs: t, classes: n } }(this.componentDef.selectors[0]); y && qi(u, c, y), w && w.length > 0 && Lu(u, c, w.join(" ")) } if (g = Qa(h, J), void 0 !== n) { const y = g.projection = []; for (let w = 0; w < this.ngContentSelectors.length; w++) { const M = n[w]; y.push(null != M ? Array.from(M) : null) } } m = function (e, t, n, r, o) { const i = n[1], s = function (e, t, n) { const r = ge(); e.firstCreatePass && (n.providersResolver && n.providersResolver(n), mp(e, r, t, Sr(e, t, 1, null), n)); const o = Eo(t, e, r.directiveStart, r); Te(o, t); const i = ft(r, t); return i && Te(i, t), o }(i, n, t); if (r.components.push(s), e[8] = s, o && o.forEach(u => u(s, t)), t.contentQueries) { const u = ge(); t.contentQueries(1, s, u.directiveStart) } const a = ge(); return !i.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (Cn(a.index), fp(n[1], a, 0, a.directiveStart, a.directiveEnd, t), hp(t, s)), s }(_, this.componentDef, p, f, [Yb]), Bo(h, p, null) } finally { $i() } return new BI(this.componentType, m, Qr(g, p), p, g) } } class BI extends class { }{ constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new PI(o), this.componentType = t } get injector() { return new yr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } class Jn { } const Yr = new Map; class $m extends Jn { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Bm(this); const r = lt(t); this._bootstrapComponents = Wt(r.bootstrap), this._r3Injector = Ip(t, n, [{ provide: Jn, useValue: this }, { provide: zr, useValue: this.componentFactoryResolver }], k(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, n = X.THROW_IF_NOT_FOUND, r = A.Default) { return t === X || t === Jn || t === jo ? this : this._r3Injector.get(t, n, r) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Ol extends class { }{ constructor(t) { super(), this.moduleType = t, null !== lt(t) && function (e) { const t = new Set; !function n(r) { const o = lt(r, !0), i = o.id; null !== i && (function (e, t, n) { if (t && t !== n) throw new Error(`Duplicate module registered for ${e} - ${k(t)} vs ${k(t.name)}`) }(i, Yr.get(i), r), Yr.set(i, r)); const s = Wt(o.imports); for (const a of s) t.has(a) || (t.add(a), n(a)) }(e) }(t) } create(t) { return new $m(this.moduleType, t) } } function Vl(e) { return t => { setTimeout(e, void 0, t) } } const xe = class extends ir { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { var u, l, c; let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const d = t; o = null == (u = d.next) ? void 0 : u.bind(d), i = null == (l = d.error) ? void 0 : l.bind(d), s = null == (c = d.complete) ? void 0 : c.bind(d) } this.__isAsync && (i = Vl(i), o && (o = Vl(o)), s && (s = Vl(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof Et && t.add(a), a } }; Symbol; const lA = function () { return e = ge(), t = D(), 4 & e.type ? new dA(t, e, Qr(e, t)) : null; var e, t }; let cn = (() => { class e { } return e.__NG_ELEMENT_ID__ = lA, e })(); const cA = cn, dA = class extends cA { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t) { const n = this._declarationTContainer.tViews, r = Lo(this._declarationLView, n, t, 16, null, n.declTNode, null, null, null, null); r[17] = this._declarationLView[this._declarationTContainer.index]; const i = this._declarationLView[19]; return null !== i && (r[19] = i.createEmbeddedView(n)), Bo(n, r, t), new Jo(r) } }; const pA = function () { return function (e, t) { let n; const r = t[e.index]; if (wt(r)) n = r; else { let o; if (8 & e.type) o = fe(r); else { const i = t[O]; o = i.createComment(""); const s = ft(e, t); Qn(i, as(i, s), o, function (e, t) { return ae(e) ? e.nextSibling(t) : t.nextSibling }(i, s), !1) } t[e.index] = n = yp(r, t, o, e), ps(t, n) } return new Qm(n, e, t) }(ge(), D()) }; let Yt = (() => { class e { } return e.__NG_ELEMENT_ID__ = pA, e })(); const mA = Yt, Qm = class extends mA { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return Qr(this._hostTNode, this._hostLView) } get injector() { return new yr(this._hostTNode, this._hostLView) } get parentInjector() { const t = Ki(this._hostTNode, this._hostLView); if (Rf(t)) { const n = mr(t, this._hostLView), r = gr(t); return new yr(n[1].data[r + 8], n) } return new yr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = Km(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, n, r) { const o = t.createEmbeddedView(n || {}); return this.insert(o, r), o } createComponent(t, n, r, o, i) { const s = t && !("function" == typeof t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.ngModuleRef } const u = s ? t : new Rl(Ie(t)), l = r || this.parentInjector; if (!i && null == u.ngModule && l) { const d = l.get(Jn, null); d && (i = d) } const c = u.create(l, o, void 0, i); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, o = r[1]; if (wt(r[3])) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[3], f = new Qm(d, d[6], d[3]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function (e, t, n, r) { const o = 10 + r, i = n.length; r > 0 && (n[o - 1][4] = t), r < i - 10 ? (t[4] = n[o], Ji(n, 10 + r, t)) : (n.push(t), t[4] = null), t[3] = n; const s = t[17]; null !== s && n !== s && function (e, t) { const n = e[9]; t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(e), t[2] |= 128 }(o, r, s, i); const a = Vu(i, s), u = r[O], l = as(u, s[7]); return null !== l && function (e, t, n, r, o, i) { r[0] = o, r[6] = t, Vo(e, r, n, 1, o, i) }(o, s[6], u, r, l, a), t.attachToViewContainerRef(), Ji(kl(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = Km(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = Ru(this._lContainer, n); r && (Un(kl(this._lContainer), n), Sh(r[1], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = Ru(this._lContainer, n); return r && null != Un(kl(this._lContainer), n) ? new Jo(r) : null } _adjustIndex(t, n = 0) { return null == t ? this.length + n : t } }; function Km(e) { return e[8] } function kl(e) { return e[8] || (e[8] = []) } const Vs = new $("Application Initializer"); let Jr = (() => { class e { constructor(n) { this.appInits = n, this.resolve = Ts, this.reject = Ts, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (Ds(i)) n.push(i); else if (Dl(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(U(Vs, 8)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); const ni = new $("AppId"), nT = { provide: ni, useFactory: function () { return `${Ql()}${Ql()}${Ql()}` }, deps: [] }; function Ql() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Dy = new $("Platform Initializer"), Kl = new $("Platform ID"), rT = new $("appBootstrapListener"); let Yl = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); const Mn = new $("LocaleId"), Cy = new $("DefaultCurrencyCode"); class iT { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } const Zl = function (e) { return new Ol(e) }, sT = Zl, aT = function (e) { return Promise.resolve(Zl(e)) }, vy = function (e) { const t = Zl(e), r = Wt(lt(e).declarations).reduce((o, i) => { const s = Ie(i); return s && o.push(new Rl(s)), o }, []); return new iT(t, r) }, uT = vy, lT = function (e) { return Promise.resolve(vy(e)) }; let wy = (() => { class e { constructor() { this.compileModuleSync = sT, this.compileModuleAsync = aT, this.compileModuleAndAllComponentsSync = uT, this.compileModuleAndAllComponentsAsync = lT } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); const fT = (() => Promise.resolve(0))(); function Jl(e) { "undefined" == typeof Zone ? fT.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Me { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new xe(!1), this.onMicrotaskEmpty = new xe(!1), this.onStable = new xe(!1), this.onError = new xe(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function () { let e = W.requestAnimationFrame, t = W.cancelAnimationFrame; if ("undefined" != typeof Zone && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function (e) { const t = () => { !function (e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(W, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, ec(e), e.isCheckStableRunning = !0, Xl(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), ec(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return by(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), My(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return by(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), My(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, ec(e), Xl(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Me.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Me.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, pT, Ts, Ts); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const pT = {}; function Xl(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function ec(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function by(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function My(e) { e._nesting--, Xl(e) } class yT { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new xe, this.onMicrotaskEmpty = new xe, this.onStable = new xe, this.onError = new xe } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } let tc = (() => { class e { constructor(n) { this._ngZone = n, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Me.assertNotInAngularZone(), Jl(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Jl(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(U(Me)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(), Iy = (() => { class e { constructor() { this._applications = new Map, nc.addToWindow(this) } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return nc.findTestabilityInTree(this, n, r) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); class _T { addToWindow(t) { } findTestabilityInTree(t, n, r) { return null } } let nc = new _T, Ay = !0, Ty = !1; let xt; const Ny = new $("AllowMultipleToken"); function xy(e, t, n = []) { const r = `Platform: ${t}`, o = new $(r); return (i = []) => { let s = Fy(); if (!s || s.injector.get(Ny, !1)) if (e) e(n.concat(i).concat({ provide: o, useValue: !0 })); else { const a = n.concat(i).concat({ provide: o, useValue: !0 }, { provide: Ho, useValue: "platform" }); !function (e) { if (xt && !xt.destroyed && !xt.injector.get(Ny, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); xt = e.get(Ry); const t = e.get(Dy, null); t && t.forEach(n => n()) }(X.create({ providers: a, name: r })) } return function (e) { const t = Fy(); if (!t) throw new Error("No platform exists!"); if (!t.injector.get(e, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return t }(o) } } function Fy() { return xt && !xt.destroyed ? xt : null } let Ry = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const a = function (e, t) { let n; return n = "noop" === e ? new yT : ("zone.js" === e ? void 0 : e) || new Me({ enableLongStackTrace: (Ty = !0, Ay), shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing) }), n }(r ? r.ngZone : void 0, { ngZoneEventCoalescing: r && r.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: r && r.ngZoneRunCoalescing || !1 }), u = [{ provide: Me, useValue: a }]; return a.run(() => { const l = X.create({ providers: u, parent: this.injector, name: n.moduleType.name }), c = n.create(l), d = c.injector.get(zn, null); if (!d) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return a.runOutsideAngular(() => { const f = a.onError.subscribe({ next: h => { d.handleError(h) } }); c.onDestroy(() => { rc(this._modules, c), f.unsubscribe() }) }), function (e, t, n) { try { const r = n(); return Ds(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(d, a, () => { const f = c.injector.get(Jr); return f.runInitializers(), f.donePromise.then(() => (function (e) { Xe(e, "Expected localeId to be defined"), "string" == typeof e && (lm = e.toLowerCase().replace(/_/g, "-")) }(c.injector.get(Mn, ws) || ws), this._moduleDoBootstrap(c), c)) }) }) } bootstrapModule(n, r = []) { const o = Py({}, r); return function (e, t, n) { const r = new Ol(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(ri); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new Error(`The module ${k(n.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(n => n.destroy()), this._destroyListeners.forEach(n => n()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(U(X)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); function Py(e, t) { return Array.isArray(t) ? t.reduce(Py, e) : Oe(Oe({}, e), t) } let ri = (() => { class e { constructor(n, r, o, i, s) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._componentFactoryResolver = i, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const a = new be(l => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { l.next(this._stable), l.complete() }) }), u = new be(l => { let c; this._zone.runOutsideAngular(() => { c = this._zone.onStable.subscribe(() => { Me.assertNotInAngularZone(), Jl(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, l.next(!0)) }) }) }); const d = this._zone.onUnstable.subscribe(() => { Me.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { l.next(!1) })) }); return () => { c.unsubscribe(), d.unsubscribe() } }); this.isStable = UC(a, u.pipe(function (e = {}) { const { connector: t = (() => new ir), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s = null, a = null, u = null, l = 0, c = !1, d = !1; const f = () => { null == a || a.unsubscribe(), a = null }, h = () => { f(), s = u = null, c = d = !1 }, p = () => { const m = s; h(), null == m || m.unsubscribe() }; return sr((m, g) => { l++, !d && !c && f(); const _ = u = null != u ? u : t(); g.add(() => { l--, 0 === l && !d && !c && (a = Ra(p, o)) }), _.subscribe(g), s || (s = new wa({ next: y => _.next(y), error: y => { d = !0, f(), a = Ra(h, n, y), _.error(y) }, complete: () => { c = !0, f(), a = Ra(h, r), _.complete() } }), Fa(m).subscribe(s)) })(i) } }())) } bootstrap(n, r) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let o; o = n instanceof Pm ? n : this._componentFactoryResolver.resolveComponentFactory(n), this.componentTypes.push(o.componentType); const i = function (e) { return e.isBoundToModule }(o) ? void 0 : this._injector.get(Jn), a = o.create(X.NULL, [], r || o.selector, i), u = a.location.nativeElement, l = a.injector.get(tc, null), c = l && a.injector.get(Iy); return l && c && c.registerApplication(u, l), a.onDestroy(() => { this.detachView(a.hostView), rc(this.components, a), c && c.unregisterApplication(u) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; rc(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(rT, []).concat(this._bootstrapListeners).forEach(o => o(n)) } ngOnDestroy() { this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return e.\u0275fac = function (n) { return new (n || e)(U(Me), U(X), U(zn), U(zr), U(Jr)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); function rc(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class Hy { constructor() { } supports(t) { return Go(t) } create(t) { return new QT(t) } } const zT = (e, t) => t; class QT { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || zT } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < Uy(r, o, i) ? n : r, a = Uy(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const l = a - o, c = u - o; if (l != c) { for (let f = 0; f < l; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < l && (i[f] = h + 1) } i[s.previousIndex] = c - l } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !Go(t)) throw new Error(`Error trying to diff '${k(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function (e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Rr()](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new KT(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new $y), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new $y), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class KT { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class YT { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class $y { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new YT, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Uy(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } class Gy { constructor() { } supports(t) { return t instanceof Map || fl(t) } create() { return new ZT } } class ZT { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let n; for (n = this._mapHead; null !== n; n = n._next)t(n) } forEachPreviousItem(t) { let n; for (n = this._previousMapHead; null !== n; n = n._nextPrevious)t(n) } forEachChangedItem(t) { let n; for (n = this._changesHead; null !== n; n = n._nextChanged)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } diff(t) { if (t) { if (!(t instanceof Map || fl(t))) throw new Error(`Error trying to diff '${k(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(t, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { const i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, n) { if (t) { const r = t._prev; return n._next = t, n._prev = r, t._prev = n, r && (r._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(t, n) { if (this._records.has(t)) { const o = this._records.get(t); this._maybeAddToChanges(o, n); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new JT(t); return this._records.set(t, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, n) { Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, n) { t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(r => n(t[r], r)) } } class JT { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Wy() { return new oi([new Hy]) } let oi = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || Wy()), deps: [[e, new Wn, new $t]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new Error(`Cannot find a differ supporting object '${n}' of type '${function (e) { return e.name || typeof e }(n)}'`) } } return e.\u0275prov = Q({ token: e, providedIn: "root", factory: Wy }), e })(); function qy() { return new Xr([new Gy]) } let Xr = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || qy()), deps: [[e, new Wn, new $t]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (r) return r; throw new Error(`Cannot find a differ supporting object '${n}'`) } } return e.\u0275prov = Q({ token: e, providedIn: "root", factory: qy }), e })(); const eS = [new Gy], nS = new oi([new Hy]), rS = new Xr(eS), oS = xy(null, "core", [{ provide: Kl, useValue: "unknown" }, { provide: Ry, deps: [X] }, { provide: Iy, deps: [] }, { provide: Yl, deps: [] }]), lS = [{ provide: ri, useClass: ri, deps: [Me, X, zn, zr, Jr] }, { provide: VI, deps: [Me], useFactory: function (e) { let t = []; return e.onStable.subscribe(() => { for (; t.length;)t.pop()() }), function (n) { t.push(n) } } }, { provide: Jr, useClass: Jr, deps: [[new $t, Vs]] }, { provide: wy, useClass: wy, deps: [] }, nT, { provide: oi, useFactory: function () { return nS }, deps: [] }, { provide: Xr, useFactory: function () { return rS }, deps: [] }, { provide: Mn, useFactory: function (e) { return e || "undefined" != typeof $localize && $localize.locale || ws }, deps: [[new So(Mn), new $t, new Wn]] }, { provide: Cy, useValue: "USD" }]; let dS = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(U(ri)) }, e.\u0275mod = yn({ type: e }), e.\u0275inj = Lt({ providers: lS }), e })(), Ys = null; function rr() { return Ys } const Ge = new $("DocumentToken"); var he = (() => ((he = he || {})[he.Zero = 0] = "Zero", he[he.One = 1] = "One", he[he.Two = 2] = "Two", he[he.Few = 3] = "Few", he[he.Many = 4] = "Many", he[he.Other = 5] = "Other", he))(); const hx = function (e) { return function (e) { const t = function (e) { return e.toLowerCase().replace(/_/g, "-") }(e); let n = um(t); if (n) return n; const r = t.split("-")[0]; if (n = um(r), n) return n; if ("en" === r) return MM; throw new Error(`Missing locale data for the locale "${e}".`) }(e)[v.PluralCase] }; class sa { } let $x = (() => { class e extends sa { constructor(n) { super(), this.locale = n } getPluralCategory(n, r) { switch (hx(r || this.locale)(n)) { case he.Zero: return "zero"; case he.One: return "one"; case he.Two: return "two"; case he.Few: return "few"; case he.Many: return "many"; default: return "other" } } } return e.\u0275fac = function (n) { return new (n || e)(U(Mn)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); class qx { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let j_ = (() => { class e { constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (r) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${function (e) { return e.name || typeof e }(n)}'. NgFor only supports binding to Iterables such as Arrays.`) } } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = []; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) { const a = this._viewContainer.createEmbeddedView(this._template, new qx(null, this._ngForOf, -1, -1), null === s ? void 0 : s), u = new H_(o, a); r.push(u) } else if (null == s) this._viewContainer.remove(null === i ? void 0 : i); else if (null !== i) { const a = this._viewContainer.get(i); this._viewContainer.move(a, s); const u = new H_(o, a); r.push(u) } }); for (let o = 0; o < r.length; o++)this._perViewChange(r[o].view, r[o].record); for (let o = 0, i = this._viewContainer.length; o < i; o++) { const s = this._viewContainer.get(o); s.context.index = o, s.context.count = i, s.context.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { this._viewContainer.get(o.currentIndex).context.$implicit = o.item }) } _perViewChange(n, r) { n.context.$implicit = r.item } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(C(Yt), C(cn), C(oi)) }, e.\u0275dir = R({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), e })(); class H_ { constructor(t, n) { this.record = t, this.view = n } } let vF = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = yn({ type: e }), e.\u0275inj = Lt({ providers: [{ provide: sa, useClass: $x }] }), e })(); class Uc extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { var e; e = new Uc, Ys || (Ys = e) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = (_i = _i || document.querySelector("base"), _i ? _i.getAttribute("href") : null); return null == n ? null : function (e) { aa = aa || document.createElement("a"), aa.setAttribute("href", e); const t = aa.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { _i = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function (e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null }(document.cookie, t) } } let aa, _i = null; const z_ = new $("TRANSITION_ID"), FF = [{ provide: Vs, useFactory: function (e, t, n) { return () => { n.get(Jr).donePromise.then(() => { const r = rr(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [z_, Ge, X], multi: !0 }]; class Gc { static init() { var e; e = new Gc, nc = e } addToWindow(t) { W.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, W.getAllAngularTestabilities = () => t.getAllTestabilities(), W.getAllAngularRootElements = () => t.getAllRootElements(), W.frameworkStabilizers || (W.frameworkStabilizers = []), W.frameworkStabilizers.push(r => { const o = W.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { if (null == n) return null; const o = t.getTestability(n); return null != o ? o : r ? rr().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null } } let RF = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); const Di = new $("EventManagerPlugins"); let la = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => o.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(U(Di), U(Me)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); class Wc { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = rr().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let K_ = (() => { class e { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(o => { this._stylesSet.has(o) || (this._stylesSet.add(o), r.add(o)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(), Ci = (() => { class e extends K_ { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, o) { n.forEach(i => { const s = this._doc.createElement("style"); s.textContent = i, o.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(Y_), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, o) => { this._addStylesToHost(n, o, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(Y_)) } } return e.\u0275fac = function (n) { return new (n || e)(U(Ge)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); function Y_(e) { rr().remove(e) } const qc = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, zc = /%COMP%/g; function ca(e, t, n) { for (let r = 0; r < t.length; r++) { let o = t[r]; Array.isArray(o) ? ca(e, o, n) : (o = o.replace(zc, e), n.push(o)) } return n } function X_(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let Qc = (() => { class e { constructor(n, r, o) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.rendererByCompId = new Map, this.defaultRenderer = new Kc(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case et.Emulated: { let o = this.rendererByCompId.get(r.id); return o || (o = new QF(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, o)), o.applyToHost(n), o } case 1: case et.ShadowDom: return new KF(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const o = ca(r.id, r.styles, []); this.sharedStylesHost.addStyles(o), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(U(la), U(Ci), U(ni)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); class Kc { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(qc[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { t.appendChild(n) } insertBefore(t, n, r) { t && t.insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = qc[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = qc[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (st.DashCase | st.Important) ? t.style.setProperty(n, r, o & st.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & st.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, X_(r)) : this.eventManager.addEventListener(t, n, X_(r)) } } class QF extends Kc { constructor(t, n, r, o) { super(t), this.component = r; const i = ca(o + "-" + r.id, r.styles, []); n.addStyles(i), this.contentAttr = "_ngcontent-%COMP%".replace(zc, o + "-" + r.id), this.hostAttr = "_nghost-%COMP%".replace(zc, o + "-" + r.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } class KF extends Kc { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = ca(o.id, o.styles, []); for (let s = 0; s < i.length; s++) { const a = document.createElement("style"); a.textContent = i[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let YF = (() => { class e extends Wc { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(U(Ge)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); const nD = ["alt", "control", "meta", "shift"], r1 = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, rD = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, o1 = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let i1 = (() => { class e extends Wc { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => rr().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = ""; if (nD.forEach(u => { const l = r.indexOf(u); l > -1 && (r.splice(l, 1), s += u + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const a = {}; return a.domEventName = o, a.fullKey = s, a } static getEventFullKey(n) { let r = "", o = function (e) { let t = e.key; if (null == t) { if (t = e.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === e.location && rD.hasOwnProperty(t) && (t = rD[t])) } return r1[t] || t }(n); return o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), nD.forEach(i => { i != o && o1[i](n) && (r += i + ".") }), r += o, r } static eventCallback(n, r, o) { return i => { e.getEventFullKey(i) === n && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(U(Ge)) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac }), e })(); const h1 = xy(oS, "browser", [{ provide: Kl, useValue: "browser" }, { provide: Dy, useValue: function () { Uc.makeCurrent(), Gc.init() }, multi: !0 }, { provide: Ge, useFactory: function () { return e = document, qa = e, document; var e }, deps: [] }]), p1 = [[], { provide: Ho, useValue: "root" }, { provide: zn, useFactory: function () { return new zn }, deps: [] }, { provide: Di, useClass: YF, multi: !0, deps: [Ge, Me, Kl] }, { provide: Di, useClass: i1, multi: !0, deps: [Ge] }, [], { provide: Qc, useClass: Qc, deps: [la, Ci, ni] }, { provide: Ss, useExisting: Qc }, { provide: K_, useExisting: Ci }, { provide: Ci, useClass: Ci, deps: [Ge] }, { provide: tc, useClass: tc, deps: [Me] }, { provide: la, useClass: la, deps: [Di, Me] }, { provide: class { }, useClass: RF, deps: [] }, []]; let g1 = (() => { class e { constructor(n) { if (n) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: ni, useValue: n.appId }, { provide: z_, useExisting: ni }, FF] } } } return e.\u0275fac = function (n) { return new (n || e)(U(e, 12)) }, e.\u0275mod = yn({ type: e }), e.\u0275inj = Lt({ providers: p1, imports: [vF, dS] }), e })(); "undefined" != typeof window && window; const { isArray: w1 } = Array, { getPrototypeOf: b1, prototype: M1, keys: I1 } = Object; const { isArray: S1 } = Array; function F1(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) } function R1(...e) { const t = function (e) { return G(xa(e)) ? e.pop() : void 0 }(e), { args: n, keys: r } = function (e) { if (1 === e.length) { const t = e[0]; if (w1(t)) return { args: t, keys: null }; if (function (e) { return e && "object" == typeof e && b1(e) === M1 }(t)) { const n = I1(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e), o = new be(i => { const { length: s } = n; if (!s) return void i.complete(); const a = new Array(s); let u = s, l = s; for (let c = 0; c < s; c++) { let d = !1; On(n[c]).subscribe(new ar(i, f => { d || (d = !0, l--), a[c] = f }, () => u--, void 0, () => { (!u || !d) && (l || i.next(r ? F1(r, a) : a), i.complete()) })) } }); return t ? o.pipe(function (e) { return Ta(t => function (e, t) { return S1(t) ? e(...t) : e(t) }(e, t)) }(t)) : o } let iD = (() => { class e { constructor(n, r) { this._renderer = n, this._elementRef = r, this.onChange = o => { }, this.onTouched = () => { } } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } } return e.\u0275fac = function (n) { return new (n || e)(C(Zn), C(Ne)) }, e.\u0275dir = R({ type: e }), e })(), or = (() => { class e extends iD { } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = function (e) { return mn(() => { const t = e.prototype.constructor, n = t[en] || uu(t), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[en] || uu(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) }(e)))(r || e) } }(), e.\u0275dir = R({ type: e, features: [re] }), e })(); const Zt = new $("NgValueAccessor"), O1 = { provide: Zt, useExisting: Z(() => da), multi: !0 }, k1 = new $("CompositionEventMode"); let da = (() => { class e extends iD { constructor(n, r, o) { super(n, r), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const e = rr() ? rr().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(n) { this.setProperty("value", null == n ? "" : n) } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } } return e.\u0275fac = function (n) { return new (n || e)(C(Zn), C(Ne), C(k1, 8)) }, e.\u0275dir = R({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (n, r) { 1 & n && Ye("input", function (i) { return r._handleInput(i.target.value) })("blur", function () { return r.onTouched() })("compositionstart", function () { return r._compositionStart() })("compositionend", function (i) { return r._compositionEnd(i.target.value) }) }, features: [oe([O1]), re] }), e })(); const Pe = new $("NgValidators"), Nn = new $("NgAsyncValidators"); function mD(e) { return null != e } function yD(e) { const t = Ds(e) ? Fa(e) : e; return Dl(t), t } function _D(e) { let t = {}; return e.forEach(n => { t = null != n ? Oe(Oe({}, t), n) : t }), 0 === Object.keys(t).length ? null : t } function DD(e, t) { return t.map(n => n(e)) } function CD(e) { return e.map(t => function (e) { return !e.validate }(t) ? t : n => t.validate(n)) } function ed(e) { return null != e ? function (e) { if (!e) return null; const t = e.filter(mD); return 0 == t.length ? null : function (n) { return _D(DD(n, t)) } }(CD(e)) : null } function td(e) { return null != e ? function (e) { if (!e) return null; const t = e.filter(mD); return 0 == t.length ? null : function (n) { return R1(DD(n, t).map(yD)).pipe(Ta(_D)) } }(CD(e)) : null } function wD(e, t) { return null === e ? [t] : Array.isArray(e) ? [...e, t] : [e, t] } function nd(e) { return e ? Array.isArray(e) ? e : [e] : [] } function fa(e, t) { return Array.isArray(e) ? e.includes(t) : e === t } function ID(e, t) { const n = nd(t); return nd(e).forEach(o => { fa(n, o) || n.push(o) }), n } function AD(e, t) { return nd(t).filter(n => !fa(e, n)) } class TD { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = ed(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = td(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, n) { return !!this.control && this.control.hasError(t, n) } getError(t, n) { return this.control ? this.control.getError(t, n) : null } } class We extends TD { get formDirective() { return null } get path() { return null } } class xn extends TD { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } let ND = (() => { class e extends class { constructor(t) { this._cd = t } is(t) { var n, r, o; return "submitted" === t ? !!(null == (n = this._cd) ? void 0 : n.submitted) : !!(null == (o = null == (r = this._cd) ? void 0 : r.control) ? void 0 : o[t]) } }{ constructor(n) { super(n) } } return e.\u0275fac = function (n) { return new (n || e)(C(xn, 2)) }, e.\u0275dir = R({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (n, r) { 2 & n && Cs("ng-untouched", r.is("untouched"))("ng-touched", r.is("touched"))("ng-pristine", r.is("pristine"))("ng-dirty", r.is("dirty"))("ng-valid", r.is("valid"))("ng-invalid", r.is("invalid"))("ng-pending", r.is("pending")) }, features: [re] }), e })(); function Ei(e, t) { (function (e, t) { const n = function (e) { return e._rawValidators }(e); null !== t.validator ? e.setValidators(wD(n, t.validator)) : "function" == typeof n && e.setValidators([n]); const r = function (e) { return e._rawAsyncValidators }(e); null !== t.asyncValidator ? e.setAsyncValidators(wD(r, t.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const o = () => e.updateValueAndValidity(); ma(t._rawValidators, o), ma(t._rawAsyncValidators, o) })(e, t), t.valueAccessor.writeValue(e.value), function (e, t) { t.valueAccessor.registerOnChange(n => { e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && xD(e, t) }) }(e, t), function (e, t) { const n = (r, o) => { t.valueAccessor.writeValue(r), o && t.viewToModelUpdate(r) }; e.registerOnChange(n), t._registerOnDestroy(() => { e._unregisterOnChange(n) }) }(e, t), function (e, t) { t.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && xD(e, t), "submit" !== e.updateOn && e.markAsTouched() }) }(e, t), function (e, t) { if (t.valueAccessor.setDisabledState) { const n = r => { t.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(n), t._registerOnDestroy(() => { e._unregisterOnDisabledChange(n) }) } }(e, t) } function ma(e, t) { e.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(t) }) } function xD(e, t) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function _a(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const vi = "VALID", Da = "INVALID", io = "PENDING", wi = "DISABLED"; function ud(e) { return (cd(e) ? e.validators : e) || null } function PD(e) { return Array.isArray(e) ? ed(e) : e || null } function ld(e, t) { return (cd(t) ? t.asyncValidators : e) || null } function OD(e) { return Array.isArray(e) ? td(e) : e || null } function cd(e) { return null != e && !Array.isArray(e) && "object" == typeof e } class dd { constructor(t, n) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = n, this._composedValidatorFn = PD(this._rawValidators), this._composedAsyncValidatorFn = OD(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === vi } get invalid() { return this.status === Da } get pending() { return this.status == io } get disabled() { return this.status === wi } get enabled() { return this.status !== wi } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = PD(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = OD(t) } addValidators(t) { this.setValidators(ID(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(ID(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(AD(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(AD(t, this._rawAsyncValidators)) } hasValidator(t) { return fa(this._rawValidators, t) } hasAsyncValidator(t) { return fa(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => { n.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => { n.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = io, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = wi, this.errors = null, this._forEachChild(r => { r.disable(lo(Oe({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(lo(Oe({}, t), { skipPristineCheck: n })), this._onDisabledChange.forEach(r => r(!0)) } enable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = vi, this._forEachChild(r => { r.enable(lo(Oe({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(lo(Oe({}, t), { skipPristineCheck: n })), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === vi || this.status === io) && this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? wi : vi } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = io, this._hasOwnPendingAsyncValidator = !0; const n = yD(this.asyncValidator(this)); this._asyncValidationSubscription = n.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, n = {}) { this.errors = t, this._updateControlsErrors(!1 !== n.emitEvent) } get(t) { return function (e, t, n) { if (null == t || (Array.isArray(t) || (t = t.split(".")), Array.isArray(t) && 0 === t.length)) return null; let r = e; return t.forEach(o => { r = r instanceof fd ? r.controls.hasOwnProperty(o) ? r.controls[o] : null : r instanceof J1 && r.at(o) || null }), r }(this, t) } getError(t, n) { const r = n ? this.get(n) : this; return r && r.errors ? r.errors[t] : null } hasError(t, n) { return !!this.getError(t, n) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new xe, this.statusChanges = new xe } _calculateStatus() { return this._allControlsDisabled() ? wi : this.errors ? Da : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(io) ? io : this._anyControlsHaveStatus(Da) ? Da : vi } _anyControlsHaveStatus(t) { return this._anyControls(n => n.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { cd(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class Ca extends dd { constructor(t = null, n, r) { super(ud(n), ld(r, n)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(t, n = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== n.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== n.emitViewToModelChange)), this.updateValueAndValidity(n) } patchValue(t, n = {}) { this.setValue(t, n) } reset(t = null, n = {}) { this._applyFormState(t), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { _a(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { _a(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class fd extends dd { constructor(t, n, r) { super(ud(n), ld(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, n) { return this.controls[t] ? this.controls[t] : (this.controls[t] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n) } addControl(t, n, r = {}) { this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(t, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } setControl(t, n, r = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], n && this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, n = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(r => { this._throwIfControlMissing(r), this.controls[r].setValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { null != t && (Object.keys(t).forEach(r => { this.controls[r] && this.controls[r].patchValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = {}, n = {}) { this._forEachChild((r, o) => { r.reset(t[o], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this._reduceChildren({}, (t, n, r) => (t[r] = n instanceof Ca ? n.value : n.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (n, r) => !!r._syncPendingControls() || n); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(n => { const r = this.controls[n]; r && t(r, n) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const n of Object.keys(this.controls)) { const r = this.controls[n]; if (this.contains(n) && t(r)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, n, r) => ((n.enabled || this.disabled) && (t[r] = n.value), t)) } _reduceChildren(t, n) { let r = t; return this._forEachChild((o, i) => { r = n(r, o, i) }), r } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((n, r) => { if (void 0 === t[r]) throw new Error(`Must supply a value for form control with name: '${r}'.`) }) } } class J1 extends dd { constructor(t, n, r) { super(ud(n), ld(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[t] } push(t, n = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } insert(t, n, r = {}) { this.controls.splice(t, 0, n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: r.emitEvent }) } removeAt(t, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } setControl(t, n, r = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), n && (this.controls.splice(t, 0, n), this._registerControl(n)), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, n = {}) { this._checkAllValuesPresent(t), t.forEach((r, o) => { this._throwIfControlMissing(o), this.at(o).setValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { null != t && (t.forEach((r, o) => { this.at(o) && this.at(o).patchValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = [], n = {}) { this._forEachChild((r, o) => { r.reset(t[o], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this.controls.map(t => t instanceof Ca ? t.value : t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(n => n._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((n, r) => !!r._syncPendingControls() || n, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((n, r) => { t(n, r) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(n => n.enabled && t(n)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((n, r) => { if (void 0 === t[r]) throw new Error(`Must supply a value for form control at index: ${r}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const tR = { provide: xn, useExisting: Z(() => pd) }, LD = (() => Promise.resolve(null))(); let pd = (() => { class e extends xn { constructor(n, r, o, i) { super(), this.control = new Ca, this._registered = !1, this.update = new xe, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = function (e, t) { if (!t) return null; let n, r, o; return Array.isArray(t), t.forEach(i => { i.constructor === da ? n = i : function (e) { return Object.getPrototypeOf(e.constructor) === or }(i) ? r = i : o = i }), o || r || n || null }(0, i) } ngOnChanges(n) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in n && this._updateDisabled(n), function (e, t) { if (!e.hasOwnProperty("model")) return !1; const n = e.model; return !!n.isFirstChange() || !Object.is(t, n.currentValue) }(n, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? function (e, t) { return [...t.path, e] }(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { Ei(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(n) { LD.then(() => { this.control.setValue(n, { emitViewToModelChange: !1 }) }) } _updateDisabled(n) { const r = n.isDisabled.currentValue, o = "" === r || r && "false" !== r; LD.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable() }) } } return e.\u0275fac = function (n) { return new (n || e)(C(We, 9), C(Pe, 10), C(Nn, 10), C(Zt, 10)) }, e.\u0275dir = R({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [oe([tR]), re, nt] }), e })(), jD = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = yn({ type: e }), e.\u0275inj = Lt({}), e })(), IR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = yn({ type: e }), e.\u0275inj = Lt({ imports: [[jD]] }), e })(), AR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = yn({ type: e }), e.\u0275inj = Lt({ imports: [IR] }), e })(); class Ea { constructor(t = "", n = "", r = "", o = 0) { this.sender = "", this.time = "", this.content = "", this.number = 0, this.sender = t, this.time = n, this.content = r, this.number = o } } const iC = { now: () => (iC.delegate || Date).now(), delegate: void 0 }; class Ed extends ir { constructor(t = 1 / 0, n = 1 / 0, r = iC) { super(), this._bufferSize = t, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, n) } next(t) { const { isStopped: n, _buffer: r, _infiniteTimeWindow: o, _timestampProvider: i, _windowTime: s } = this; n || (r.push(t), !o && r.push(i.now() + s)), this._trimBuffer(), super.next(t) } _subscribe(t) { this._throwIfClosed(), this._trimBuffer(); const n = this._innerSubscribe(t), { _infiniteTimeWindow: r, _buffer: o } = this, i = o.slice(); for (let s = 0; s < i.length && !t.closed; s += r ? 1 : 2)t.next(i[s]); return this._checkFinalizedStatuses(t), n } _trimBuffer() { const { _bufferSize: t, _timestampProvider: n, _buffer: r, _infiniteTimeWindow: o } = this, i = (o ? 1 : 2) * t; if (t < 1 / 0 && i < r.length && r.splice(0, r.length - i), !o) { const s = n.now(); let a = 0; for (let u = 1; u < r.length && r[u] <= s; u += 2)a = u; a && r.splice(0, a + 1) } } } const TR = { url: "", deserializer: e => JSON.parse(e.data), serializer: e => JSON.stringify(e) }; class vd extends Aa { constructor(t, n) { if (super(), this._socket = null, t instanceof be) this.destination = n, this.source = t; else { const r = this._config = Object.assign({}, TR); if (this._output = new ir, "string" == typeof t) r.url = t; else for (const o in t) t.hasOwnProperty(o) && (r[o] = t[o]); if (!r.WebSocketCtor && WebSocket) r.WebSocketCtor = WebSocket; else if (!r.WebSocketCtor) throw new Error("no WebSocket constructor can be found"); this.destination = new Ed } } lift(t) { const n = new vd(this._config, this.destination); return n.operator = t, n.source = this, n } _resetState() { this._socket = null, this.source || (this.destination = new Ed), this._output = new ir } multiplex(t, n, r) { const o = this; return new be(i => { try { o.next(t()) } catch (a) { i.error(a) } const s = o.subscribe(a => { try { r(a) && i.next(a) } catch (u) { i.error(u) } }, a => i.error(a), () => i.complete()); return () => { try { o.next(n()) } catch (a) { i.error(a) } s.unsubscribe() } }) } _connectSocket() { const { WebSocketCtor: t, protocol: n, url: r, binaryType: o } = this._config, i = this._output; let s = null; try { s = n ? new t(r, n) : new t(r), this._socket = s, o && (this._socket.binaryType = o) } catch (u) { return void i.error(u) } const a = new Et(() => { this._socket = null, s && 1 === s.readyState && s.close() }); s.onopen = u => { const { _socket: l } = this; if (!l) return s.close(), void this._resetState(); const { openObserver: c } = this._config; c && c.next(u); const d = this.destination; this.destination = Si.create(f => { if (1 === s.readyState) try { const { serializer: h } = this._config; s.send(h(f)) } catch (h) { this.destination.error(h) } }, f => { const { closingObserver: h } = this._config; h && h.next(void 0), f && f.code ? s.close(f.code, f.reason) : i.error(new TypeError("WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }")), this._resetState() }, () => { const { closingObserver: f } = this._config; f && f.next(void 0), s.close(), this._resetState() }), d && d instanceof Ed && a.add(d.subscribe(this.destination)) }, s.onerror = u => { this._resetState(), i.error(u) }, s.onclose = u => { this._resetState(); const { closeObserver: l } = this._config; l && l.next(u), u.wasClean ? i.complete() : i.error(u) }, s.onmessage = u => { try { const { deserializer: l } = this._config; i.next(l(u)) } catch (l) { i.error(l) } } } _subscribe(t) { const { source: n } = this; return n ? n.subscribe(t) : (this._socket || this._connectSocket(), this._output.subscribe(t), t.add(() => { const { _socket: r } = this; 0 === this._output.observers.length && (r && (1 === r.readyState || 0 === r.readyState) && r.close(), this._resetState()) }), t) } unsubscribe() { const { _socket: t } = this; t && (1 === t.readyState || 0 === t.readyState) && t.close(), this._resetState(), super.unsubscribe() } } let sC = (() => { class e { constructor() { this.GACHOCHAT_ENDPOINT = "wss://chat-ws.gacho.duckdns.org:16788/" } connectGachoChat() { return this.connect(this.GACHOCHAT_ENDPOINT) } connect(n) { return this.connection$ || (this.connection$ = function (e) { return new vd(e) }(n)), this.connection$ } send(n) { console.log("Sending message"), console.log(n), this.connection$ ? this.connection$.next(n) : console.error("Connection has not been created, cannot send " + String(n)) } closeConnection() { this.connection$ ? (this.connection$.complete(), delete this.connection$) : console.log("Tried to close connection, but no connection exists. ") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = Q({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class xR { constructor(t) { this.type = "chat", this.content = "", this.content = t } } let FR = (() => { class e { constructor(n) { this.chatService = n, this._myMessage = "" } set myMessage(n) { this._myMessage = n } ngOnInit() { } sendMessage() { console.log("Sending chat"), this.chatService.send(new xR(this._myMessage)) } } return e.\u0275fac = function (n) { return new (n || e)(C(sC)) }, e.\u0275cmp = ho({ type: e, selectors: [["app-ChatComposer"]], decls: 3, vars: 1, consts: [["type", "text", 3, "ngModel", "ngModelChange"], [3, "click"]], template: function (n, r) { 1 & n && (Qe(0, "input", 0), Ye("ngModelChange", function (i) { return r.myMessage = i }), Ke(), Qe(1, "button", 1), Ye("click", function () { return r.sendMessage() }), ln(2, ">"), Ke()), 2 & n && qo("ngModel", r.myMessage) }, directives: [da, ND, pd], styles: [""] }), e })(), RR = (() => { class e { constructor() { this.myMessage = new Ea } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ho({ type: e, selectors: [["app-chatMessage"]], inputs: { myMessage: "myMessage" }, decls: 2, vars: 3, template: function (n, r) { 1 & n && (Qe(0, "p"), ln(1), Ke()), 2 & n && (ko(1), bl(" ", r.myMessage.sender, ": ", r.myMessage.content, " - ", r.myMessage.time, "\n")) }, styles: [""] }), e })(); function PR(e, t) { 1 & e && _l(0, "app-chatMessage", 6), 2 & e && qo("myMessage", t.$implicit) } let OR = (() => { class e { constructor(n) { this.chatService = n, this.title = "gachoChat", this.messages = [], this.users = "", this.actions = "", this.messages.push(new Ea("Gacho", "", "Chat gestartet")) } ngOnInit() { this.chatService.connectGachoChat().subscribe({ next: n => this.parseMessage(n), error: n => console.error(n), complete: () => console.warn("Chat server called complete") }) } parseMessage(n) { switch (console.log("Message received"), console.log(n), n.type) { case "users": this.users = n.content.toString(); break; case "joined": case "left": this.actions = "User " + n.content.toString() + " " + n.type; break; case "action": this.actions = "User " + n.content.toString() + " pressed Action!"; let r = new Ea(n.user, n.time, n.text); this.messages.push(r), this.messages.sort((i, s) => i.number > s.number ? -1 : 1); break; case "chat": let o = new Ea(n.content.user, n.content.time, n.content.text); this.messages.push(o), this.messages.sort((i, s) => i.number > s.number ? -1 : 1); break; default: console.warn("unsupported event", n) } } onAction() { console.log("Action!"); let n = new VR; n.content = "action", this.chatService.send(n) } } return e.\u0275fac = function (n) { return new (n || e)(C(sC)) }, e.\u0275cmp = ho({ type: e, selectors: [["app-root"]], decls: 17, vars: 3, consts: [["href", "https://gacho.duckdns.org"], [3, "myMessage", 4, "ngFor", "ngForOf"], [1, "buttons"], [1, "action", "button", 3, "click"], [1, "users"], [1, "actions"], [3, "myMessage"]], template: function (n, r) { 1 & n && (Qe(0, "h1"), ln(1, "Salut. "), Ke(), Qe(2, "a", 0), ln(3, "\u30ac\u30c1\u30e7\u30a6"), Ke(), Qe(4, "h2"), ln(5, "Nachrichten"), Ke(), function (e, t, n, r, o, i, s, a) { const u = D(), l = H(), c = e + J, d = l.firstCreatePass ? function (e, t, n, r, o, i, s, a, u) { const l = t.consts, c = Tr(t, e, 4, s || null, Dn(l, a)); Zu(t, n, c, Dn(l, u)), Ui(t, c); const d = c.tViews = hs(2, c, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, l); return null !== t.queries && (t.queries.template(t, c), d.queries = t.queries.embeddedTView(c)), c }(c, l, u, t, n, r, o, i, s) : l.data[c]; jt(d, !1); const f = u[O].createComment(""); us(l, u, f, d), Te(f, u), ps(u, u[c] = yp(f, u, f, d)), ki(d) && Ku(l, u, d), null != s && Yu(u, d, a) }(6, PR, 1, 1, "app-chatMessage", 1), _l(7, "app-ChatComposer"), Qe(8, "div", 2), Qe(9, "div", 3), Ye("click", function () { return r.onAction() }), ln(10, "Action!"), Ke(), Ke(), Qe(11, "div"), Qe(12, "span", 4), ln(13), Ke(), Ke(), Qe(14, "div"), Qe(15, "span", 5), ln(16), Ke(), Ke()), 2 & n && (ko(6), qo("ngForOf", r.messages), ko(7), vs(r.users), ko(3), vs(r.actions)) }, directives: [j_, FR, RR], styles: ['body[_ngcontent-%COMP%]{font-family:"Courier New",sans-serif;text-align:center}.buttons[_ngcontent-%COMP%]{font-size:4em;display:flex;justify-content:center}.button[_ngcontent-%COMP%], .value[_ngcontent-%COMP%]{line-height:1;padding:2rem;margin:2rem;border:medium solid;min-height:1em;min-width:1em}'] }), e })(); class VR { constructor() { this.type = "chat", this.content = "" } } let kR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = yn({ type: e, bootstrap: [OR] }), e.\u0275inj = Lt({ providers: [], imports: [[g1, AR]] }), e })(); (function () { if (Ty) throw new Error("Cannot enable prod mode after platform setup."); Ay = !1 })(), h1().bootstrapModule(kR).catch(e => console.error(e)) } }, G => { G(G.s = 490) }]);